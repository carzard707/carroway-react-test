{"ast":null,"code":"import { last } from \"./utils.js\";\nfunction joinPaths(paths) {\n  return cleanPath(paths.filter(val => {\n    return val !== void 0;\n  }).join(\"/\"));\n}\nfunction cleanPath(path) {\n  return path.replace(/\\/{2,}/g, \"/\");\n}\nfunction trimPathLeft(path) {\n  return path === \"/\" ? path : path.replace(/^\\/{1,}/, \"\");\n}\nfunction trimPathRight(path) {\n  return path === \"/\" ? path : path.replace(/\\/{1,}$/, \"\");\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction removeTrailingSlash(value, basepath) {\n  if (value.endsWith(\"/\") && value !== \"/\" && value !== `${basepath}/`) {\n    return value.slice(0, -1);\n  }\n  return value;\n}\nfunction exactPathTest(pathName1, pathName2, basepath) {\n  return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);\n}\nfunction resolvePath(_ref) {\n  let {\n    basepath,\n    base,\n    to,\n    trailingSlash = \"never\"\n  } = _ref;\n  var _a, _b;\n  base = removeBasepath(basepath, base);\n  to = removeBasepath(basepath, to);\n  let baseSegments = parsePathname(base);\n  const toSegments = parsePathname(to);\n  if (baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === \"/\") {\n    baseSegments.pop();\n  }\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === \"/\") {\n      if (!index) {\n        baseSegments = [toSegment];\n      } else if (index === toSegments.length - 1) {\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (toSegment.value === \"..\") {\n      baseSegments.pop();\n    } else if (toSegment.value === \".\") ;else {\n      baseSegments.push(toSegment);\n    }\n  });\n  if (baseSegments.length > 1) {\n    if (((_b = last(baseSegments)) == null ? void 0 : _b.value) === \"/\") {\n      if (trailingSlash === \"never\") {\n        baseSegments.pop();\n      }\n    } else if (trailingSlash === \"always\") {\n      baseSegments.push({\n        type: \"pathname\",\n        value: \"/\"\n      });\n    }\n  }\n  const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);\n  return cleanPath(joined);\n}\nfunction parsePathname(pathname) {\n  if (!pathname) {\n    return [];\n  }\n  pathname = cleanPath(pathname);\n  const segments = [];\n  if (pathname.slice(0, 1) === \"/\") {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  if (!pathname) {\n    return segments;\n  }\n  const split = pathname.split(\"/\").filter(Boolean);\n  segments.push(...split.map(part => {\n    if (part === \"$\" || part === \"*\") {\n      return {\n        type: \"wildcard\",\n        value: part\n      };\n    }\n    if (part.charAt(0) === \"$\") {\n      return {\n        type: \"param\",\n        value: part\n      };\n    }\n    return {\n      type: \"pathname\",\n      value: decodeURIComponent(part)\n    };\n  }));\n  if (pathname.slice(-1) === \"/\") {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  return segments;\n}\nfunction interpolatePath(_ref2) {\n  let {\n    path,\n    params,\n    leaveWildcards,\n    leaveParams\n  } = _ref2;\n  const interpolatedPathSegments = parsePathname(path);\n  const encodedParams = {};\n  for (const [key, value] of Object.entries(params)) {\n    const isValueString = typeof value === \"string\";\n    if ([\"*\", \"_splat\"].includes(key)) {\n      encodedParams[key] = isValueString ? encodeURI(value) : value;\n    } else {\n      encodedParams[key] = isValueString ? encodeURIComponent(value) : value;\n    }\n  }\n  return joinPaths(interpolatedPathSegments.map(segment => {\n    if (segment.type === \"wildcard\") {\n      const value = encodedParams._splat;\n      if (leaveWildcards) return `${segment.value}${value ?? \"\"}`;\n      return value;\n    }\n    if (segment.type === \"param\") {\n      if (leaveParams) {\n        const value = encodedParams[segment.value];\n        return `${segment.value}${value ?? \"\"}`;\n      }\n      return encodedParams[segment.value.substring(1)] ?? \"undefined\";\n    }\n    return segment.value;\n  }));\n}\nfunction matchPathname(basepath, currentPathname, matchLocation) {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation);\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n  return pathParams ?? {};\n}\nfunction removeBasepath(basepath, pathname) {\n  switch (true) {\n    case basepath === \"/\":\n      return pathname;\n    case pathname === basepath:\n      return \"\";\n    case pathname.length < basepath.length:\n      return pathname;\n    case pathname[basepath.length] !== \"/\":\n      return pathname;\n    case pathname.startsWith(basepath):\n      return pathname.slice(basepath.length);\n    default:\n      return pathname;\n  }\n}\nfunction matchByPath(basepath, from, matchLocation) {\n  from = removeBasepath(basepath, from);\n  const to = removeBasepath(basepath, `${matchLocation.to ?? \"$\"}`);\n  const baseSegments = parsePathname(from);\n  const routeSegments = parsePathname(to);\n  if (!from.startsWith(\"/\")) {\n    baseSegments.unshift({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  if (!to.startsWith(\"/\")) {\n    routeSegments.unshift({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  const params = {};\n  const isMatch = (() => {\n    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {\n      const baseSegment = baseSegments[i];\n      const routeSegment = routeSegments[i];\n      const isLastBaseSegment = i >= baseSegments.length - 1;\n      const isLastRouteSegment = i >= routeSegments.length - 1;\n      if (routeSegment) {\n        if (routeSegment.type === \"wildcard\") {\n          const _splat = decodeURI(joinPaths(baseSegments.slice(i).map(d => d.value)));\n          params[\"*\"] = _splat;\n          params[\"_splat\"] = _splat;\n          return true;\n        }\n        if (routeSegment.type === \"pathname\") {\n          if (routeSegment.value === \"/\" && !(baseSegment == null ? void 0 : baseSegment.value)) {\n            return true;\n          }\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false;\n              }\n            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n              return false;\n            }\n          }\n        }\n        if (!baseSegment) {\n          return false;\n        }\n        if (routeSegment.type === \"param\") {\n          if (baseSegment.value === \"/\") {\n            return false;\n          }\n          if (baseSegment.value.charAt(0) !== \"$\") {\n            params[routeSegment.value.substring(1)] = decodeURIComponent(baseSegment.value);\n          }\n        }\n      }\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params[\"**\"] = joinPaths(baseSegments.slice(i + 1).map(d => d.value));\n        return !!matchLocation.fuzzy && (routeSegment == null ? void 0 : routeSegment.value) !== \"/\";\n      }\n    }\n    return true;\n  })();\n  return isMatch ? params : void 0;\n}\nexport { cleanPath, exactPathTest, interpolatePath, joinPaths, matchByPath, matchPathname, parsePathname, removeBasepath, removeTrailingSlash, resolvePath, trimPath, trimPathLeft, trimPathRight };","map":{"version":3,"names":["joinPaths","paths","cleanPath","filter","val","join","path","replace","trimPathLeft","trimPathRight","trimPath","removeTrailingSlash","value","basepath","endsWith","slice","exactPathTest","pathName1","pathName2","resolvePath","_ref","base","to","trailingSlash","removeBasepath","baseSegments","parsePathname","toSegments","length","_a","last","pop","forEach","toSegment","index","push","_b","type","joined","map","d","pathname","segments","substring","split","Boolean","part","charAt","decodeURIComponent","interpolatePath","_ref2","params","leaveWildcards","leaveParams","interpolatedPathSegments","encodedParams","key","Object","entries","isValueString","includes","encodeURI","encodeURIComponent","segment","_splat","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","startsWith","from","routeSegments","unshift","isMatch","i","Math","max","baseSegment","routeSegment","isLastBaseSegment","isLastRouteSegment","decodeURI","caseSensitive","toLowerCase","fuzzy"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react/node_modules/@tanstack/react-router/src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  basepath: string\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n}\n\nexport function resolvePath({\n  basepath,\n  base,\n  to,\n  trailingSlash = 'never',\n}: ResolvePathOptions) {\n  base = removeBasepath(basepath, base)\n  to = removeBasepath(basepath, to)\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)?.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: 'pathname', value: '/' })\n    }\n  }\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Array<Segment> {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: decodeURIComponent(part),\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n}\n\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n}: InterpolatePathOptions) {\n  const interpolatedPathSegments = parsePathname(path)\n  const encodedParams: any = {}\n\n  for (const [key, value] of Object.entries(params)) {\n    const isValueString = typeof value === 'string'\n\n    if (['*', '_splat'].includes(key)) {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      encodedParams[key] = isValueString ? encodeURI(value) : value\n    } else {\n      encodedParams[key] = isValueString ? encodeURIComponent(value) : value\n    }\n  }\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = encodedParams._splat\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        if (leaveParams) {\n          const value = encodedParams[segment.value]\n          return `${segment.value}${value ?? ''}`\n        }\n        return encodedParams![segment.value.substring(1)] ?? 'undefined'\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(basepath: string, pathname: string) {\n  switch (true) {\n    // default behaviour is to serve app from the root - pathname\n    // left untouched\n    case basepath === '/':\n      return pathname\n\n    // shortcut for removing the basepath from the equal pathname\n    case pathname === basepath:\n      return ''\n\n    // in case pathname is shorter than basepath - there is\n    // nothing to remove\n    case pathname.length < basepath.length:\n      return pathname\n\n    // avoid matching partial segments - strict equality handled\n    // earlier, otherwise, basepath separated from pathname with\n    // separator, therefore lack of separator means partial\n    // segment match (`/app` should not match `/application`)\n    case pathname[basepath.length] !== '/':\n      return pathname\n\n    // remove the basepath from the pathname in case there is any\n    case pathname.startsWith(basepath):\n      return pathname.slice(basepath.length)\n\n    // otherwise, return the pathname as is\n    default:\n      return pathname\n  }\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from)\n  // Default to to $ (wildcard)\n  const to = removeBasepath(basepath, `${matchLocation.to ?? '$'}`)\n\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  const isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          const _splat = decodeURI(\n            joinPaths(baseSegments.slice(i).map((d) => d.value)),\n          )\n          // TODO: Deprecate *\n          params['*'] = _splat\n          params['_splat'] = _splat\n          return true\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = decodeURIComponent(\n              baseSegment.value,\n            )\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value))\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/'\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? params : undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}