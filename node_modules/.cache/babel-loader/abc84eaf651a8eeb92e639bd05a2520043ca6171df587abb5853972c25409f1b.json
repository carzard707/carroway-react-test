{"ast":null,"code":"import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useBlocker(blockerFnOrOpts, condition) {\n  const {\n    blockerFn,\n    blockerCondition\n  } = blockerFnOrOpts ? typeof blockerFnOrOpts === \"function\" ? {\n    blockerFn: blockerFnOrOpts,\n    blockerCondition: condition ?? true\n  } : {\n    blockerFn: blockerFnOrOpts.blockerFn,\n    blockerCondition: blockerFnOrOpts.condition ?? true\n  } : {\n    blockerFn: void 0,\n    blockerCondition: condition ?? true\n  };\n  const {\n    history\n  } = useRouter();\n  const [resolver, setResolver] = React.useState({\n    status: \"idle\",\n    proceed: () => {},\n    reset: () => {}\n  });\n  React.useEffect(() => {\n    const blockerFnComposed = async () => {\n      if (blockerFn) {\n        return await blockerFn();\n      }\n      const promise = new Promise(resolve => {\n        setResolver({\n          status: \"blocked\",\n          proceed: () => resolve(true),\n          reset: () => resolve(false)\n        });\n      });\n      const canNavigateAsync = await promise;\n      setResolver({\n        status: \"idle\",\n        proceed: () => {},\n        reset: () => {}\n      });\n      return canNavigateAsync;\n    };\n    return !blockerCondition ? void 0 : history.block(blockerFnComposed);\n  }, [blockerFn, blockerCondition, history]);\n  return resolver;\n}\nfunction Block(_ref) {\n  let {\n    blockerFn,\n    condition,\n    children\n  } = _ref;\n  const resolver = useBlocker({\n    blockerFn,\n    condition\n  });\n  return children ? typeof children === \"function\" ? children(resolver) : children : null;\n}\nexport { Block, useBlocker };","map":{"version":3,"names":["useBlocker","blockerFnOrOpts","condition","blockerFn","blockerCondition","history","useRouter","resolver","setResolver","React","useState","status","proceed","reset","useEffect","blockerFnComposed","promise","Promise","resolve","canNavigateAsync","block","Block","_ref","children"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react/node_modules/@tanstack/react-router/src/useBlocker.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport type { BlockerFn } from '@tanstack/history'\nimport type { ReactNode } from './route'\n\ntype BlockerResolver = {\n  status: 'idle' | 'blocked'\n  proceed: () => void\n  reset: () => void\n}\n\ntype BlockerOpts = {\n  blockerFn?: BlockerFn\n  condition?: boolean | any\n}\n\nexport function useBlocker(blockerFnOrOpts?: BlockerOpts): BlockerResolver\n\n/**\n * @deprecated Use the BlockerOpts object syntax instead\n */\nexport function useBlocker(\n  blockerFn?: BlockerFn,\n  condition?: boolean | any,\n): BlockerResolver\n\nexport function useBlocker(\n  blockerFnOrOpts?: BlockerFn | BlockerOpts,\n  condition?: boolean | any,\n): BlockerResolver {\n  const { blockerFn, blockerCondition } = blockerFnOrOpts\n    ? typeof blockerFnOrOpts === 'function'\n      ? { blockerFn: blockerFnOrOpts, blockerCondition: condition ?? true }\n      : {\n          blockerFn: blockerFnOrOpts.blockerFn,\n          blockerCondition: blockerFnOrOpts.condition ?? true,\n        }\n    : { blockerFn: undefined, blockerCondition: condition ?? true }\n  const { history } = useRouter()\n\n  const [resolver, setResolver] = React.useState<BlockerResolver>({\n    status: 'idle',\n    proceed: () => {},\n    reset: () => {},\n  })\n\n  React.useEffect(() => {\n    const blockerFnComposed = async () => {\n      // If a function is provided, it takes precedence over the promise blocker\n      if (blockerFn) {\n        return await blockerFn()\n      }\n\n      const promise = new Promise<boolean>((resolve) => {\n        setResolver({\n          status: 'blocked',\n          proceed: () => resolve(true),\n          reset: () => resolve(false),\n        })\n      })\n\n      const canNavigateAsync = await promise\n\n      setResolver({\n        status: 'idle',\n        proceed: () => {},\n        reset: () => {},\n      })\n\n      return canNavigateAsync\n    }\n\n    return !blockerCondition ? undefined : history.block(blockerFnComposed)\n  }, [blockerFn, blockerCondition, history])\n\n  return resolver\n}\n\nexport function Block({ blockerFn, condition, children }: PromptProps) {\n  const resolver = useBlocker({ blockerFn, condition })\n  return children\n    ? typeof children === 'function'\n      ? children(resolver)\n      : children\n    : null\n}\n\nexport type PromptProps = {\n  blockerFn?: BlockerFn\n  condition?: boolean | any\n  children?: ReactNode | (({ proceed, reset }: BlockerResolver) => ReactNode)\n}\n"],"mappings":";;AA0BgB,SAAAA,WACdC,eAAA,EACAC,SAAA,EACiB;EACjB,MAAM;IAAEC,SAAA;IAAWC;EAAA,IAAqBH,eAAA,GACpC,OAAOA,eAAA,KAAoB,aACzB;IAAEE,SAAA,EAAWF,eAAA;IAAiBG,gBAAA,EAAkBF,SAAA,IAAa;EAAA,IAC7D;IACEC,SAAA,EAAWF,eAAA,CAAgBE,SAAA;IAC3BC,gBAAA,EAAkBH,eAAA,CAAgBC,SAAA,IAAa;EAAA,IAEnD;IAAEC,SAAA,EAAW;IAAWC,gBAAA,EAAkBF,SAAA,IAAa;EAAA;EACrD;IAAEG;EAAA,IAAYC,SAAA;EAEpB,MAAM,CAACC,QAAA,EAAUC,WAAW,IAAIC,KAAA,CAAMC,QAAA,CAA0B;IAC9DC,MAAA,EAAQ;IACRC,OAAA,EAASA,CAAA,KAAM,CAAC;IAChBC,KAAA,EAAOA,CAAA,KAAM,CAAC;EAAA,CACf;EAEDJ,KAAA,CAAMK,SAAA,CAAU,MAAM;IACpB,MAAMC,iBAAA,GAAoB,MAAAA,CAAA,KAAY;MAEpC,IAAIZ,SAAA,EAAW;QACb,OAAO,MAAMA,SAAA,CAAU;MACzB;MAEA,MAAMa,OAAA,GAAU,IAAIC,OAAA,CAAkBC,OAAA,IAAY;QACpCV,WAAA;UACVG,MAAA,EAAQ;UACRC,OAAA,EAASA,CAAA,KAAMM,OAAA,CAAQ,IAAI;UAC3BL,KAAA,EAAOA,CAAA,KAAMK,OAAA,CAAQ,KAAK;QAAA,CAC3B;MAAA,CACF;MAED,MAAMC,gBAAA,GAAmB,MAAMH,OAAA;MAEnBR,WAAA;QACVG,MAAA,EAAQ;QACRC,OAAA,EAASA,CAAA,KAAM,CAAC;QAChBC,KAAA,EAAOA,CAAA,KAAM,CAAC;MAAA,CACf;MAEM,OAAAM,gBAAA;IAAA;IAGT,OAAO,CAACf,gBAAA,GAAmB,SAAYC,OAAA,CAAQe,KAAA,CAAML,iBAAiB;EACrE,IAACZ,SAAA,EAAWC,gBAAA,EAAkBC,OAAO,CAAC;EAElC,OAAAE,QAAA;AACT;AAEO,SAASc,MAAAC,IAAA,EAAuD;EAAA,IAAjD;IAAEnB,SAAA;IAAWD,SAAA;IAAWqB;EAAA,IAAAD,IAAA;EAC5C,MAAMf,QAAA,GAAWP,UAAA,CAAW;IAAEG,SAAA;IAAWD;EAAW;EACpD,OAAOqB,QAAA,GACH,OAAOA,QAAA,KAAa,aAClBA,QAAA,CAAShB,QAAQ,IACjBgB,QAAA,GACF;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}