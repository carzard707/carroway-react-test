{"ast":null,"code":"function encode(obj, pfx) {\n  let k,\n    i,\n    tmp,\n    str = \"\";\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += \"&\");\n          str += encodeURIComponent(k) + \"=\" + encodeURIComponent(tmp[i]);\n        }\n      } else {\n        str && (str += \"&\");\n        str += encodeURIComponent(k) + \"=\" + encodeURIComponent(tmp);\n      }\n    }\n  }\n  return (pfx || \"\") + str;\n}\nfunction toValue(mix) {\n  if (!mix) return \"\";\n  const str = decodeURIComponent(mix);\n  if (str === \"false\") return false;\n  if (str === \"true\") return true;\n  return +str * 0 === 0 && +str + \"\" === str ? +str : str;\n}\nfunction decode(str, pfx) {\n  let tmp, k;\n  const out = {},\n    arr = (pfx ? str.substr(pfx.length) : str).split(\"&\");\n  while (tmp = arr.shift()) {\n    const equalIndex = tmp.indexOf(\"=\");\n    if (equalIndex !== -1) {\n      k = tmp.slice(0, equalIndex);\n      const value = tmp.slice(equalIndex + 1);\n      if (out[k] !== void 0) {\n        out[k] = [].concat(out[k], toValue(value));\n      } else {\n        out[k] = toValue(value);\n      }\n    } else {\n      k = tmp;\n      out[k] = \"\";\n    }\n  }\n  return out;\n}\nexport { decode, encode };","map":{"version":3,"names":["encode","obj","pfx","k","i","tmp","str","Array","isArray","length","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","arr","substr","split","shift","equalIndex","indexOf","slice","value","concat"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react-test/node_modules/@tanstack/react-router/src/qss.ts"],"sourcesContent":["// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\n/**\n * Encodes an object into a query string.\n * @param obj - The object to encode into a query string.\n * @param [pfx] - An optional prefix to add before the query string.\n * @returns The encoded query string.\n * @example\n * ```\n * // Example input: encode({ token: 'foo', key: 'value' })\n * // Expected output: \"token=foo&key=value\"\n * ```\n */\nexport function encode(obj: any, pfx?: string) {\n  let k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\n/**\n * Converts a string value to its appropriate type (string, number, boolean).\n * @param mix - The string value to convert.\n * @returns The converted value.\n * @example\n * // Example input: toValue(\"123\")\n * // Expected output: 123\n */\nfunction toValue(mix: any) {\n  if (!mix) return ''\n  const str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\n/**\n * Decodes a query string into an object.\n * @param str - The query string to decode.\n * @param [pfx] - An optional prefix to filter out from the query string.\n * @returns The decoded key-value pairs in an object format.\n * @example\n * // Example input: decode(\"token=foo&key=value\")\n * // Expected output: { \"token\": \"foo\", \"key\": \"value\" }\n */\nexport function decode(str: any, pfx?: string) {\n  let tmp, k\n  const out: any = {},\n    arr = (pfx ? str.substr(pfx.length) : str).split('&')\n\n  while ((tmp = arr.shift())) {\n    const equalIndex = tmp.indexOf('=')\n    if (equalIndex !== -1) {\n      k = tmp.slice(0, equalIndex)\n      const value = tmp.slice(equalIndex + 1)\n      if (out[k] !== void 0) {\n        // @ts-expect-error\n        out[k] = [].concat(out[k], toValue(value))\n      } else {\n        out[k] = toValue(value)\n      }\n    } else {\n      k = tmp\n      out[k] = ''\n    }\n  }\n\n  return out\n}\n"],"mappings":"AAagB,SAAAA,OAAOC,GAAA,EAAUC,GAAA,EAAc;EACzC,IAAAC,CAAA;IACFC,CAAA;IACAC,GAAA;IACAC,GAAA,GAAM;EAER,KAAKH,CAAA,IAAKF,GAAA,EAAK;IACb,KAAKI,GAAA,GAAMJ,GAAA,CAAIE,CAAC,OAAO,QAAQ;MACzB,IAAAI,KAAA,CAAMC,OAAA,CAAQH,GAAG,GAAG;QACtB,KAAKD,CAAA,GAAI,GAAGA,CAAA,GAAIC,GAAA,CAAII,MAAA,EAAQL,CAAA,IAAK;UAC/BE,GAAA,KAAQA,GAAA,IAAO;UACfA,GAAA,IAAOI,kBAAA,CAAmBP,CAAC,IAAI,MAAMO,kBAAA,CAAmBL,GAAA,CAAID,CAAC,CAAC;QAChE;MAAA,OACK;QACLE,GAAA,KAAQA,GAAA,IAAO;QACfA,GAAA,IAAOI,kBAAA,CAAmBP,CAAC,IAAI,MAAMO,kBAAA,CAAmBL,GAAG;MAC7D;IACF;EACF;EAEA,QAAQH,GAAA,IAAO,MAAMI,GAAA;AACvB;AAUA,SAASK,QAAQC,GAAA,EAAU;EACrB,KAACA,GAAA,EAAY;EACX,MAAAN,GAAA,GAAMO,kBAAA,CAAmBD,GAAG;EAC9B,IAAAN,GAAA,KAAQ,SAAgB;EACxB,IAAAA,GAAA,KAAQ,QAAe;EACpB,QAACA,GAAA,GAAM,MAAM,KAAK,CAACA,GAAA,GAAM,OAAOA,GAAA,GAAM,CAACA,GAAA,GAAMA,GAAA;AACtD;AAWgB,SAAAQ,OAAOR,GAAA,EAAUJ,GAAA,EAAc;EAC7C,IAAIG,GAAA,EAAKF,CAAA;EACT,MAAMY,GAAA,GAAW,CACf;IAAAC,GAAA,IAAOd,GAAA,GAAMI,GAAA,CAAIW,MAAA,CAAOf,GAAA,CAAIO,MAAM,IAAIH,GAAA,EAAKY,KAAA,CAAM,GAAG;EAE9C,OAAAb,GAAA,GAAMW,GAAA,CAAIG,KAAA,IAAU;IACpB,MAAAC,UAAA,GAAaf,GAAA,CAAIgB,OAAA,CAAQ,GAAG;IAClC,IAAID,UAAA,KAAe,IAAI;MACjBjB,CAAA,GAAAE,GAAA,CAAIiB,KAAA,CAAM,GAAGF,UAAU;MAC3B,MAAMG,KAAA,GAAQlB,GAAA,CAAIiB,KAAA,CAAMF,UAAA,GAAa,CAAC;MAClC,IAAAL,GAAA,CAAIZ,CAAC,MAAM,QAAQ;QAEjBY,GAAA,CAAAZ,CAAC,IAAI,GAAGqB,MAAA,CAAOT,GAAA,CAAIZ,CAAC,GAAGQ,OAAA,CAAQY,KAAK,CAAC;MAAA,OACpC;QACDR,GAAA,CAAAZ,CAAC,IAAIQ,OAAA,CAAQY,KAAK;MACxB;IAAA,OACK;MACDpB,CAAA,GAAAE,GAAA;MACJU,GAAA,CAAIZ,CAAC,IAAI;IACX;EACF;EAEO,OAAAY,GAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}