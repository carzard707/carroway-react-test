{"ast":null,"code":"\"use client\";\n\nimport { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useForwardedRef, deepEqual, useIntersectionObserver, functionalUpdate } from \"./utils.js\";\nimport { removeTrailingSlash, exactPathTest } from \"./path.js\";\nconst preloadWarning = \"Error preloading route! ☝️\";\nfunction useLinkProps(options, forwardedRef) {\n  const router = useRouter();\n  const [isTransitioning, setIsTransitioning] = React.useState(false);\n  const innerRef = useForwardedRef(forwardedRef);\n  const {\n    // custom props\n    activeProps = () => ({\n      className: \"active\"\n    }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ignoreBlocker,\n    ...rest\n  } = options;\n  const type = React.useMemo(() => {\n    try {\n      new URL(`${to}`);\n      return \"external\";\n    } catch {}\n    return \"internal\";\n  }, [to]);\n  const next = React.useMemo(() => router.buildLocation(options), [router, options]);\n  const preload = React.useMemo(() => userPreload ?? router.options.defaultPreload, [router.options.defaultPreload, userPreload]);\n  const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;\n  const isActive = useRouterState({\n    select: s => {\n      const currentPathSplit = removeTrailingSlash(s.location.pathname, router.basepath).split(\"/\");\n      const nextPathSplit = removeTrailingSlash(next.pathname, router.basepath).split(\"/\");\n      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);\n      const pathTest = (activeOptions == null ? void 0 : activeOptions.exact) ? exactPathTest(s.location.pathname, next.pathname, router.basepath) : pathIsFuzzyEqual;\n      const hashTest = (activeOptions == null ? void 0 : activeOptions.includeHash) ? s.location.hash === next.hash : true;\n      const searchTest = (activeOptions == null ? void 0 : activeOptions.includeSearch) ?? true ? deepEqual(s.location.search, next.search, !(activeOptions == null ? void 0 : activeOptions.exact)) : true;\n      return pathTest && hashTest && searchTest;\n    }\n  });\n  const doPreload = React.useCallback(() => {\n    router.preloadRoute(options).catch(err => {\n      console.warn(err);\n      console.warn(preloadWarning);\n    });\n  }, [options, router]);\n  const preloadViewportIoCallback = React.useCallback(entry => {\n    if (entry == null ? void 0 : entry.isIntersecting) {\n      doPreload();\n    }\n  }, [doPreload]);\n  useIntersectionObserver(innerRef, preloadViewportIoCallback, {\n    rootMargin: \"100px\"\n  }, {\n    disabled: !!disabled || preload !== \"viewport\"\n  });\n  if (type === \"external\") {\n    return {\n      ...rest,\n      ref: innerRef,\n      type,\n      href: to,\n      ...(children && {\n        children\n      }),\n      ...(target && {\n        target\n      }),\n      ...(disabled && {\n        disabled\n      }),\n      ...(style && {\n        style\n      }),\n      ...(className && {\n        className\n      }),\n      ...(onClick && {\n        onClick\n      }),\n      ...(onFocus && {\n        onFocus\n      }),\n      ...(onMouseEnter && {\n        onMouseEnter\n      }),\n      ...(onMouseLeave && {\n        onMouseLeave\n      }),\n      ...(onTouchStart && {\n        onTouchStart\n      })\n    };\n  }\n  const handleClick = e => {\n    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === \"_self\") && e.button === 0) {\n      e.preventDefault();\n      flushSync(() => {\n        setIsTransitioning(true);\n      });\n      const unsub = router.subscribe(\"onResolved\", () => {\n        unsub();\n        setIsTransitioning(false);\n      });\n      router.commitLocation({\n        ...next,\n        replace,\n        resetScroll,\n        startTransition,\n        viewTransition,\n        ignoreBlocker\n      });\n    }\n  };\n  const handleFocus = _ => {\n    if (disabled) return;\n    if (preload) {\n      doPreload();\n    }\n  };\n  const handleTouchStart = handleFocus;\n  const handleEnter = e => {\n    if (disabled) return;\n    const eventTarget = e.target || {};\n    if (preload) {\n      if (eventTarget.preloadTimeout) {\n        return;\n      }\n      eventTarget.preloadTimeout = setTimeout(() => {\n        eventTarget.preloadTimeout = null;\n        doPreload();\n      }, preloadDelay);\n    }\n  };\n  const handleLeave = e => {\n    if (disabled) return;\n    const eventTarget = e.target || {};\n    if (eventTarget.preloadTimeout) {\n      clearTimeout(eventTarget.preloadTimeout);\n      eventTarget.preloadTimeout = null;\n    }\n  };\n  const composeHandlers = handlers => e => {\n    var _a;\n    (_a = e.persist) == null ? void 0 : _a.call(e);\n    handlers.filter(Boolean).forEach(handler => {\n      if (e.defaultPrevented) return;\n      handler(e);\n    });\n  };\n  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};\n  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {});\n  const resolvedClassName = [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(\" \");\n  const resolvedStyle = {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style\n  };\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? void 0 : next.maskedLocation ? router.history.createHref(next.maskedLocation.href) : router.history.createHref(next.href),\n    ref: innerRef,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    disabled: !!disabled,\n    target,\n    ...(Object.keys(resolvedStyle).length && {\n      style: resolvedStyle\n    }),\n    ...(resolvedClassName && {\n      className: resolvedClassName\n    }),\n    ...(disabled && {\n      role: \"link\",\n      \"aria-disabled\": true\n    }),\n    ...(isActive && {\n      \"data-status\": \"active\",\n      \"aria-current\": \"page\"\n    }),\n    ...(isTransitioning && {\n      \"data-transitioning\": \"transitioning\"\n    })\n  };\n}\nfunction createLink(Comp) {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return /* @__PURE__ */jsx(Link, {\n      ...props,\n      _asChild: Comp,\n      ref\n    });\n  });\n}\nconst Link = React.forwardRef((props, ref) => {\n  const {\n    _asChild,\n    ...rest\n  } = props;\n  const {\n    type,\n    ref: innerRef,\n    ...linkProps\n  } = useLinkProps(rest, ref);\n  const children = typeof rest.children === \"function\" ? rest.children({\n    isActive: linkProps[\"data-status\"] === \"active\"\n  }) : rest.children;\n  if (typeof _asChild === \"undefined\") {\n    delete linkProps.disabled;\n  }\n  return React.createElement(_asChild ? _asChild : \"a\", {\n    ...linkProps,\n    ref: innerRef\n  }, children);\n});\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\nexport { Link, createLink, useLinkProps };","map":{"version":3,"names":["preloadWarning","useLinkProps","options","forwardedRef","router","useRouter","isTransitioning","setIsTransitioning","React","useState","innerRef","useForwardedRef","activeProps","className","activeOptions","hash","search","params","to","state","mask","preload","userPreload","preloadDelay","userPreloadDelay","replace","startTransition","resetScroll","viewTransition","children","target","disabled","style","onClick","onFocus","onMouseEnter","onMouseLeave","onTouchStart","ignoreBlocker","rest","type","useMemo","URL","next","buildLocation","defaultPreload","defaultPreloadDelay","isActive","useRouterState","select","s","currentPathSplit","removeTrailingSlash","location","pathname","basepath","split","nextPathSplit","pathIsFuzzyEqual","every","d","i","pathTest","exact","exactPathTest","hashTest","includeHash","searchTest","includeSearch","deepEqual","doPreload","useCallback","preloadRoute","catch","err","console","warn","preloadViewportIoCallback","entry","isIntersecting","useIntersectionObserver","rootMargin","ref","href","handleClick","e","isCtrlEvent","defaultPrevented","button","preventDefault","flushSync","unsub","subscribe","commitLocation","handleFocus","_","handleTouchStart","handleEnter","eventTarget","preloadTimeout","setTimeout","handleLeave","clearTimeout","composeHandlers","handlers","_a","persist","call","filter","Boolean","forEach","handler","resolvedActiveProps","functionalUpdate","resolvedInactiveProps","inactiveProps","resolvedClassName","join","resolvedStyle","maskedLocation","history","createHref","Object","keys","length","role","createLink","Comp","forwardRef","CreatedLink","props","jsx","Link","_asChild","linkProps","createElement","metaKey","altKey","ctrlKey","shiftKey"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react/node_modules/@tanstack/react-router/src/link.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport {\n  deepEqual,\n  functionalUpdate,\n  useForwardedRef,\n  useIntersectionObserver,\n} from './utils'\nimport { exactPathTest, removeTrailingSlash } from './path'\nimport type { ParsedLocation } from './location'\nimport type { HistoryState } from '@tanstack/history'\nimport type {\n  AllParams,\n  CatchAllPaths,\n  CurrentPath,\n  FullSearchSchema,\n  FullSearchSchemaInput,\n  ParentPath,\n  RouteByPath,\n  RouteByToPath,\n  RoutePaths,\n  RouteToPath,\n  TrailingSlashOptionByRouter,\n} from './routeInfo'\nimport type { AnyRouter, RegisteredRouter } from './router'\nimport type {\n  Expand,\n  MakeDifferenceOptional,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  Updater,\n  WithoutEmpty,\n} from './utils'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<TValue, TIncludeTrailingSlash = true> = TValue extends unknown\n  ? string extends TValue\n    ? Array<string>\n    : TValue extends string\n      ? CleanPath<TValue> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<TValue> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<TValue> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<TValue> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [TValue]\n          : CleanPath<TValue> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : TValue extends string\n              ? [TValue]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<\n  T extends string,\n  TAcc = never,\n> = T extends `${string}$${string}`\n  ? T extends `${string}$${infer TPossiblyParam}`\n    ? TPossiblyParam extends `${string}/${string}`\n      ? TPossiblyParam extends `${infer TParam}/${infer TRest}`\n        ? ParsePathParams<TRest, TParam extends '' ? TAcc : TParam | TAcc>\n        : never\n      : TPossiblyParam extends ''\n        ? TAcc\n        : TPossiblyParam | TAcc\n    : TAcc\n  : TAcc\n\nexport type Join<T, TDelimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [\n          infer L extends string,\n          ...infer Tail extends [...Array<string>],\n        ]\n      ? CleanPath<`${L}${TDelimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends Array<any>> = T extends [...infer _, infer L]\n  ? L\n  : never\n\nexport type RemoveTrailingSlashes<T> = T extends `${infer R}/` ? R : T\n\nexport type RemoveLeadingSlashes<T> = T extends `/${infer R}` ? R : T\n\nexport type ResolvePaths<TRouter extends AnyRouter, TSearchPath> =\n  RouteByPath<\n    TRouter['routeTree'],\n    RemoveTrailingSlashes<TSearchPath>\n  > extends never\n    ? RouteToPath<TRouter, TRouter['routeTree']>\n    : RouteToPath<\n        TRouter,\n        RouteByPath<TRouter['routeTree'], RemoveTrailingSlashes<TSearchPath>>\n      >\n\nexport type SearchPaths<\n  TRouter extends AnyRouter,\n  TSearchPath extends string,\n  TPaths = ResolvePaths<TRouter, TSearchPath>,\n> = TPaths extends `${RemoveTrailingSlashes<TSearchPath>}${infer TRest}`\n  ? TRest\n  : never\n\nexport type SearchRelativePathAutoComplete<\n  TRouter extends AnyRouter,\n  TTo extends string,\n  TSearchPath extends string,\n> = `${TTo}${SearchPaths<TRouter, TSearchPath>}`\n\nexport type RelativeToParentPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TResolvedPath extends string = RemoveTrailingSlashes<\n    ResolveRelativePath<TFrom, TTo>\n  >,\n> =\n  | SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath>\n  | (TResolvedPath extends ''\n      ? never\n      : `${TTo}/${ParentPath<TrailingSlashOptionByRouter<TRouter>>}`)\n\nexport type RelativeToCurrentPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n  TResolvedPath extends string = ResolveRelativePath<TFrom, TTo>,\n> = SearchRelativePathAutoComplete<TRouter, TTo, TResolvedPath>\n\nexport type AbsolutePathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n> =\n  | (string extends TFrom\n      ? CurrentPath<TrailingSlashOptionByRouter<TRouter>>\n      : TFrom extends `/`\n        ? never\n        : SearchPaths<TRouter, TFrom> extends ''\n          ? never\n          : CurrentPath<TrailingSlashOptionByRouter<TRouter>>)\n  | (string extends TFrom\n      ? ParentPath<TrailingSlashOptionByRouter<TRouter>>\n      : TFrom extends `/`\n        ? never\n        : ParentPath<TrailingSlashOptionByRouter<TRouter>>)\n  | RouteToPath<TRouter, TRouter['routeTree']>\n  | (TFrom extends '/'\n      ? never\n      : string extends TFrom\n        ? never\n        : RemoveLeadingSlashes<SearchPaths<TRouter, TFrom>>)\n\nexport type RelativeToPathAutoComplete<\n  TRouter extends AnyRouter,\n  TFrom extends string,\n  TTo extends string,\n> = TTo extends `..${string}`\n  ? RelativeToParentPathAutoComplete<TRouter, TFrom, RemoveTrailingSlashes<TTo>>\n  : TTo extends `.${string}`\n    ? RelativeToCurrentPathAutoComplete<\n        TRouter,\n        TFrom,\n        RemoveTrailingSlashes<TTo>\n      >\n    : AbsolutePathAutoComplete<TRouter, TFrom>\n\nexport type NavigateOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & NavigateOptionProps\n\nexport interface NavigateOptionProps {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  /** @deprecated All navigations now use startTransition under the hood */\n  startTransition?: boolean\n  // if set to `true`, the router will wrap the resulting navigation in a document.startViewTransition() call.\n  viewTransition?: boolean\n  ignoreBlocker?: boolean\n}\n\nexport type ToOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouter, TFrom, TTo> & MaskOptions<TRouter, TMaskFrom, TMaskTo>\n\nexport interface MaskOptions<\n  in out TRouter extends AnyRouter,\n  in out TMaskFrom extends RoutePaths<TRouter['routeTree']> | string,\n  in out TMaskTo extends string,\n> {\n  _fromLocation?: ParsedLocation\n  mask?: ToMaskOptions<TRouter, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRouter = RegisteredRouter,\n  TMaskFrom extends RoutePaths<TRouteTree['routeTree']> | string = string,\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n> = ToSubOptionsProps<TRouter, TFrom, TTo> &\n  SearchParamOptions<TRouter, TFrom, TTo> &\n  PathParamOptions<TRouter, TFrom, TTo>\n\nexport interface ToSubOptionsProps<\n  in out TRouter extends AnyRouter = RegisteredRouter,\n  in out TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  in out TTo extends string = '',\n> {\n  to?: ToPathOption<TRouter, TFrom, TTo> & {}\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: FromPathOption<TRouter, TFrom> & {}\n}\n\nexport type ParamsReducerFn<\n  in out TRouter extends AnyRouter,\n  in out TParamVariant extends ParamVariant,\n  in out TFrom,\n  in out TTo,\n> = (\n  current: Expand<ResolveFromParams<TRouter, TParamVariant, TFrom>>,\n) => Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n\ntype ParamsReducer<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  | Expand<ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>>\n  | (ParamsReducerFn<TRouter, TParamVariant, TFrom, TTo> & {})\n\ntype ParamVariant = 'PATH' | 'SEARCH'\n\nexport type ResolveRoute<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo,\n  TPath = ResolveRelativePath<TFrom, TTo>,\n> = TPath extends string\n  ? TFrom extends TPath\n    ? RouteByPath<TRouter['routeTree'], TPath>\n    : RouteByToPath<TRouter, TPath>\n  : never\n\ntype ResolveFromParamType<TParamVariant extends ParamVariant> =\n  TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchema'\n\ntype ResolveFromAllParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'PATH'\n  ? AllParams<TRouter['routeTree']>\n  : FullSearchSchema<TRouter['routeTree']>\n\ntype ResolveFromParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n> = string extends TFrom\n  ? ResolveFromAllParams<TRouter, TParamVariant>\n  : RouteByPath<\n      TRouter['routeTree'],\n      TFrom\n    >['types'][ResolveFromParamType<TParamVariant>]\n\ntype ResolveToParamType<TParamVariant extends ParamVariant> =\n  TParamVariant extends 'PATH' ? 'allParams' : 'fullSearchSchemaInput'\n\ntype ResolveAllToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n> = TParamVariant extends 'PATH'\n  ? AllParams<TRouter['routeTree']>\n  : FullSearchSchemaInput<TRouter['routeTree']>\n\nexport type ResolveToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  ResolveRelativePath<TFrom, TTo> extends infer TPath\n    ? string extends TPath\n      ? ResolveAllToParams<TRouter, TParamVariant>\n      : TPath extends CatchAllPaths<TrailingSlashOptionByRouter<TRouter>>\n        ? ResolveAllToParams<TRouter, TParamVariant>\n        : ResolveRoute<\n            TRouter,\n            TFrom,\n            TTo\n          >['types'][ResolveToParamType<TParamVariant>]\n    : never\n\ntype ResolveRelativeToParams<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n  TToParams = ResolveToParams<TRouter, TParamVariant, TFrom, TTo>,\n> = TParamVariant extends 'SEARCH'\n  ? TToParams\n  : string extends TFrom\n    ? TToParams\n    : MakeDifferenceOptional<\n        ResolveFromParams<TRouter, TParamVariant, TFrom>,\n        TToParams\n      >\n\ninterface MakeOptionalSearchParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  search?: true | (ParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {})\n}\n\ninterface MakeOptionalPathParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  params?: true | (ParamsReducer<TRouter, 'PATH', TFrom, TTo> & {})\n}\n\ntype MakeRequiredParamsReducer<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  | (string extends TFrom\n      ? never\n      : ResolveFromParams<TRouter, TParamVariant, TFrom> extends WithoutEmpty<\n            PickRequired<\n              ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n            >\n          >\n        ? true\n        : never)\n  | (ParamsReducer<TRouter, TParamVariant, TFrom, TTo> & {})\n\nexport interface MakeRequiredPathParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  params: MakeRequiredParamsReducer<TRouter, 'PATH', TFrom, TTo> & {}\n}\n\nexport interface MakeRequiredSearchParams<\n  in out TRouter extends AnyRouter,\n  in out TFrom,\n  in out TTo,\n> {\n  search: MakeRequiredParamsReducer<TRouter, 'SEARCH', TFrom, TTo> & {}\n}\n\nexport type IsRequiredParams<TParams> =\n  Record<never, never> extends TParams ? never : true\n\nexport type IsRequired<\n  TRouter extends AnyRouter,\n  TParamVariant extends ParamVariant,\n  TFrom,\n  TTo,\n> =\n  ResolveRelativePath<TFrom, TTo> extends infer TPath\n    ? string extends TPath\n      ? never\n      : TPath extends CatchAllPaths<TrailingSlashOptionByRouter<TRouter>>\n        ? never\n        : IsRequiredParams<\n            ResolveRelativeToParams<TRouter, TParamVariant, TFrom, TTo>\n          >\n    : never\n\nexport type SearchParamOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo extends string,\n> =\n  IsRequired<TRouter, 'SEARCH', TFrom, TTo> extends never\n    ? MakeOptionalSearchParams<TRouter, TFrom, TTo>\n    : MakeRequiredSearchParams<TRouter, TFrom, TTo>\n\nexport type PathParamOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TTo extends string,\n> =\n  IsRequired<TRouter, 'PATH', TFrom, TTo> extends never\n    ? MakeOptionalPathParams<TRouter, TFrom, TTo>\n    : MakeRequiredPathParams<TRouter, TFrom, TTo>\n\nexport type ToPathOption<\n  TRouter extends AnyRouter = AnyRouter,\n  TFrom extends string = string,\n  TTo extends string = string,\n> =\n  | CheckPath<TRouter, TTo, never, TFrom, TTo>\n  | RelativeToPathAutoComplete<\n      TRouter,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type CheckFromPath<\n  TRouter extends AnyRouter,\n  TPass,\n  TFail,\n  TFrom,\n> = string extends TFrom\n  ? TPass\n  : RouteByPath<TRouter['routeTree'], TFrom> extends never\n    ? TFail\n    : TPass\n\nexport type FromPathOption<TRouter extends AnyRouter, TFrom> =\n  | CheckFromPath<\n      TRouter,\n      string extends TFrom ? TFrom & {} : TFrom,\n      never,\n      TFrom\n    >\n  | RoutePaths<TRouter['routeTree']>\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & LinkOptionsProps\n\nexport interface LinkOptionsProps {\n  /**\n   * The standard anchor tag target attribute\n   */\n  target?: HTMLAnchorElement['target']\n  /**\n   * Configurable options to determine if the link should be considered active or not\n   * @default {exact:true,includeHash:true}\n   */\n  activeOptions?: ActiveOptions\n  /**\n   * The preloading strategy for this link\n   * - `false` - No preloading\n   * - `'intent'` - Preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n   * - `'viewport'` - Preload the linked route when it enters the viewport\n   */\n  preload?: false | 'intent' | 'viewport'\n  /**\n   * When a preload strategy is set, this delays the preload by this many milliseconds.\n   * If the user exits the link before this delay, the preload will be cancelled.\n   */\n  preloadDelay?: number\n  /**\n   * Control whether the link should be disabled or not\n   * If set to `true`, the link will be rendered without an `href` attribute\n   * @default false\n   */\n  disabled?: boolean\n}\n\nexport type CheckPath<TRouter extends AnyRouter, TPass, TFail, TFrom, TTo> =\n  string extends ResolveRelativePath<TFrom, TTo>\n    ? TPass\n    : ResolveRelativePath<TFrom, TTo> extends CatchAllPaths<\n          TrailingSlashOptionByRouter<TRouter>\n        >\n      ? TPass\n      : ResolveRoute<TRouter, TFrom, TTo> extends never\n        ? TFail\n        : TPass\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = string extends TFrom\n  ? TTo\n  : string extends TTo\n    ? TFrom\n    : TFrom extends string\n      ? TTo extends string\n        ? TTo extends '.'\n          ? TFrom\n          : TTo extends `./`\n            ? Join<[TFrom, '/']>\n            : TTo extends `./${infer TRest}`\n              ? ResolveRelativePath<TFrom, TRest>\n              : TTo extends `/${infer TRest}`\n                ? TTo\n                : Split<TTo> extends ['..', ...infer ToRest]\n                  ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                    ? ToRest extends ['/']\n                      ? Join<['/', ...FromRest, '/']>\n                      : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                    : never\n                  : Split<TTo> extends ['.', ...infer ToRest]\n                    ? ToRest extends ['/']\n                      ? Join<[TFrom, '/']>\n                      : ResolveRelativePath<TFrom, Join<ToRest>>\n                    : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n        : never\n      : never\n\n// type Test1 = ResolveRelativePath<'/', '/posts'>\n// //   ^?\n// type Test4 = ResolveRelativePath<'/posts/1/comments', '../..'>\n// //   ^?\n// type Test5 = ResolveRelativePath<'/posts/1/comments', '../../..'>\n// //   ^?\n// type Test6 = ResolveRelativePath<'/posts/1/comments', './1'>\n// //   ^?\n// type Test7 = ResolveRelativePath<'/posts/1/comments', './1/2'>\n// //   ^?\n// type Test8 = ResolveRelativePath<'/posts/1/comments', '../edit'>\n// //   ^?\n// type Test9 = ResolveRelativePath<'/posts/1/comments', '1'>\n// //   ^?\n// type Test10 = ResolveRelativePath<'/posts/1/comments', './1'>\n// //   ^?\n// type Test11 = ResolveRelativePath<'/posts/1/comments', './1/2'>\n// //   ^?\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nexport function useLinkProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n  forwardedRef?: React.ForwardedRef<Element>,\n): React.ComponentPropsWithRef<'a'> {\n  const router = useRouter()\n  const [isTransitioning, setIsTransitioning] = React.useState(false)\n  const innerRef = useForwardedRef(forwardedRef)\n\n  const {\n    // custom props\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ignoreBlocker,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const type: 'internal' | 'external' = React.useMemo(() => {\n    try {\n      new URL(`${to}`)\n      return 'external'\n    } catch {}\n    return 'internal'\n  }, [to])\n\n  const next = React.useMemo(\n    () => router.buildLocation(options as any),\n    [router, options],\n  )\n  const preload = React.useMemo(\n    () => userPreload ?? router.options.defaultPreload,\n    [router.options.defaultPreload, userPreload],\n  )\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = removeTrailingSlash(\n        s.location.pathname,\n        router.basepath,\n      ).split('/')\n      const nextPathSplit = removeTrailingSlash(\n        next.pathname,\n        router.basepath,\n      ).split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? exactPathTest(s.location.pathname, next.pathname, router.basepath)\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        (activeOptions?.includeSearch ?? true)\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  const doPreload = React.useCallback(() => {\n    router.preloadRoute(options as any).catch((err) => {\n      console.warn(err)\n      console.warn(preloadWarning)\n    })\n  }, [options, router])\n\n  const preloadViewportIoCallback = React.useCallback(\n    (entry: IntersectionObserverEntry | undefined) => {\n      if (entry?.isIntersecting) {\n        doPreload()\n      }\n    },\n    [doPreload],\n  )\n\n  useIntersectionObserver(\n    innerRef,\n    preloadViewportIoCallback,\n    { rootMargin: '100px' },\n    { disabled: !!disabled || preload !== 'viewport' },\n  )\n\n  if (type === 'external') {\n    return {\n      ...rest,\n      ref: innerRef as React.ComponentPropsWithRef<'a'>['ref'],\n      type,\n      href: to,\n      ...(children && { children }),\n      ...(target && { target }),\n      ...(disabled && { disabled }),\n      ...(style && { style }),\n      ...(className && { className }),\n      ...(onClick && { onClick }),\n      ...(onFocus && { onFocus }),\n      ...(onMouseEnter && { onMouseEnter }),\n      ...(onMouseLeave && { onMouseLeave }),\n      ...(onTouchStart && { onTouchStart }),\n    }\n  }\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      flushSync(() => {\n        setIsTransitioning(true)\n      })\n\n      const unsub = router.subscribe('onResolved', () => {\n        unsub()\n        setIsTransitioning(false)\n      })\n\n      // All is well? Navigate!\n      router.commitLocation({\n        ...next,\n        replace,\n        resetScroll,\n        startTransition,\n        viewTransition,\n        ignoreBlocker,\n      })\n    }\n  }\n\n  // The click handler\n  const handleFocus = (_: MouseEvent) => {\n    if (disabled) return\n    if (preload) {\n      doPreload()\n    }\n  }\n\n  const handleTouchStart = handleFocus\n\n  const handleEnter = (e: MouseEvent) => {\n    if (disabled) return\n    const eventTarget = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (eventTarget.preloadTimeout) {\n        return\n      }\n\n      eventTarget.preloadTimeout = setTimeout(() => {\n        eventTarget.preloadTimeout = null\n        doPreload()\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    if (disabled) return\n    const eventTarget = (e.target || {}) as LinkCurrentTargetElement\n\n    if (eventTarget.preloadTimeout) {\n      clearTimeout(eventTarget.preloadTimeout)\n      eventTarget.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: Array<undefined | ((e: any) => void)>) =>\n    (e: { persist?: () => void; defaultPrevented: boolean }) => {\n      e.persist?.()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? (functionalUpdate(activeProps as any, {}) ?? {})\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {})\n\n  const resolvedClassName = [\n    className,\n    resolvedActiveProps.className,\n    resolvedInactiveProps.className,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const resolvedStyle = {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style,\n  }\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? router.history.createHref(next.maskedLocation.href)\n        : router.history.createHref(next.href),\n    ref: innerRef as React.ComponentPropsWithRef<'a'>['ref'],\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    disabled: !!disabled,\n    target,\n    ...(Object.keys(resolvedStyle).length && { style: resolvedStyle }),\n    ...(resolvedClassName && { className: resolvedClassName }),\n    ...(disabled && {\n      role: 'link',\n      'aria-disabled': true,\n    }),\n    ...(isActive && { 'data-status': 'active', 'aria-current': 'page' }),\n    ...(isTransitioning && { 'data-transitioning': 'transitioning' }),\n  }\n}\n\nexport type UseLinkPropsOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type ActiveLinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = LinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & ActiveLinkOptionProps\n\ntype ActiveLinkAnchorProps = Omit<\n  React.AnchorHTMLAttributes<HTMLAnchorElement> & {\n    [key: `data-${string}`]: unknown\n  },\n  'children'\n>\n\nexport interface ActiveLinkOptionProps {\n  /**\n   * A function that returns additional props for the `active` state of this link.\n   * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n   */\n  activeProps?: ActiveLinkAnchorProps | (() => ActiveLinkAnchorProps)\n  /**\n   * A function that returns additional props for the `inactive` state of this link.\n   * These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n   */\n  inactiveProps?: ActiveLinkAnchorProps | (() => ActiveLinkAnchorProps)\n}\n\nexport type LinkProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> &\n  LinkPropsChildren\n\nexport interface LinkPropsChildren {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | React.ReactNode\n    | ((state: {\n        isActive: boolean\n        isTransitioning: boolean\n      }) => React.ReactNode)\n}\n\ntype LinkComponentReactProps<TComp> = React.PropsWithoutRef<\n  TComp extends React.FC<infer TProps> | React.Component<infer TProps>\n    ? TProps\n    : TComp extends keyof React.JSX.IntrinsicElements\n      ? Omit<React.HTMLProps<TComp>, 'children' | 'preload'>\n      : never\n> &\n  React.RefAttributes<\n    TComp extends\n      | React.FC<{ ref: infer TRef }>\n      | React.Component<{ ref: infer TRef }>\n      ? TRef\n      : TComp extends keyof React.JSX.IntrinsicElements\n        ? React.ComponentRef<TComp>\n        : never\n  >\n\nexport type LinkComponentProps<\n  TComp,\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = LinkComponentReactProps<TComp> &\n  LinkProps<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport type LinkComponent<TComp> = <\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n>(\n  props: LinkComponentProps<TComp, TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => React.ReactElement\n\nexport function createLink<const TComp>(Comp: TComp): LinkComponent<TComp> {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return <Link {...(props as any)} _asChild={Comp} ref={ref} />\n  }) as any\n}\n\nexport const Link: LinkComponent<'a'> = React.forwardRef<Element, any>(\n  (props, ref) => {\n    const { _asChild, ...rest } = props\n    const { type, ref: innerRef, ...linkProps } = useLinkProps(rest, ref)\n\n    const children =\n      typeof rest.children === 'function'\n        ? rest.children({\n            isActive: (linkProps as any)['data-status'] === 'active',\n          })\n        : rest.children\n\n    if (typeof _asChild === 'undefined') {\n      // the ReturnType of useLinkProps returns the correct type for a <a> element, not a general component that has a delete prop\n      // @ts-expect-error\n      delete linkProps.disabled\n    }\n\n    return React.createElement(\n      _asChild ? _asChild : 'a',\n      {\n        ...linkProps,\n        ref: innerRef,\n      },\n      children,\n    )\n  },\n) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}