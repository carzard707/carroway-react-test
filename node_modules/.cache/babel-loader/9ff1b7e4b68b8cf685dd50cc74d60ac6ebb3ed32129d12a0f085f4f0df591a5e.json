{"ast":null,"code":"import * as React from \"react\";\nfunction isModuleNotFoundError(error) {\n  return typeof (error == null ? void 0 : error.message) === \"string\" && /Failed to fetch dynamically imported module/.test(error.message);\n}\nfunction lazyRouteComponent(importer, exportName) {\n  let loadPromise;\n  let comp;\n  let error;\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer().then(res => {\n        loadPromise = void 0;\n        comp = res[exportName ?? \"default\"];\n      }).catch(err => {\n        error = err;\n      });\n    }\n    return loadPromise;\n  };\n  const lazyComp = function Lazy(props) {\n    if (error) {\n      if (isModuleNotFoundError(error)) {\n        if (error instanceof Error && typeof window !== \"undefined\" && typeof sessionStorage !== \"undefined\") {\n          const storageKey = `tanstack_router_reload:${error.message}`;\n          if (!sessionStorage.getItem(storageKey)) {\n            sessionStorage.setItem(storageKey, \"1\");\n            window.location.reload();\n            return {\n              default: () => null\n            };\n          }\n        }\n      }\n      throw error;\n    }\n    if (!comp) {\n      throw load();\n    }\n    return React.createElement(comp, props);\n  };\n  lazyComp.preload = load;\n  return lazyComp;\n}\nexport { lazyRouteComponent };","map":{"version":3,"names":["isModuleNotFoundError","error","message","test","lazyRouteComponent","importer","exportName","loadPromise","comp","load","then","res","catch","err","lazyComp","Lazy","props","Error","window","sessionStorage","storageKey","getItem","setItem","location","reload","default","React","createElement","preload"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react/node_modules/@tanstack/react-router/src/lazyRouteComponent.tsx"],"sourcesContent":["import * as React from 'react'\nimport type { AsyncRouteComponent } from './route'\n\n// If the load fails due to module not found, it may mean a new version of\n// the build was deployed and the user's browser is still using an old version.\n// If this happens, the old version in the user's browser would have an outdated\n// URL to the lazy module.\n// In that case, we want to attempt one window refresh to get the latest.\nfunction isModuleNotFoundError(error: any): boolean {\n  return (\n    typeof error?.message === 'string' &&\n    /Failed to fetch dynamically imported module/.test(error.message)\n  )\n}\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any> | undefined\n  let comp: T[TKey] | T['default']\n  let error: any\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n        .then((res) => {\n          loadPromise = undefined\n          comp = res[exportName ?? 'default']\n        })\n        .catch((err) => {\n          error = err\n        })\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = function Lazy(props: any) {\n    // Now that we're out of preload and into actual render path,\n    // throw the error if it was a module not found error during preload\n    if (error) {\n      if (isModuleNotFoundError(error)) {\n        // We don't want an error thrown from preload in this case, because\n        // there's nothing we want to do about module not found during preload.\n        // Record the error, recover the promise with a null return,\n        // and we will attempt module not found resolution during the render path.\n\n        if (\n          error instanceof Error &&\n          typeof window !== 'undefined' &&\n          typeof sessionStorage !== 'undefined'\n        ) {\n          // Again, we want to reload one time on module not found error and not enter\n          // a reload loop if there is some other issue besides an old deploy.\n          // That's why we store our reload attempt in sessionStorage.\n          // Use error.message as key because it contains the module path that failed.\n          const storageKey = `tanstack_router_reload:${error.message}`\n          if (!sessionStorage.getItem(storageKey)) {\n            sessionStorage.setItem(storageKey, '1')\n            window.location.reload()\n\n            // Return empty component while we wait for window to reload\n            return {\n              default: () => null,\n            }\n          }\n        }\n      }\n\n      // Otherwise, just throw the error\n      throw error\n    }\n\n    if (!comp) {\n      throw load()\n    }\n\n    return React.createElement(comp, props)\n  }\n\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n"],"mappings":";AAQA,SAASA,sBAAsBC,KAAA,EAAqB;EAClD,OACE,QAAOA,KAAA,oBAAAA,KAAA,CAAOC,OAAA,MAAY,YAC1B,8CAA8CC,IAAA,CAAKF,KAAA,CAAMC,OAAO;AAEpE;AAEgB,SAAAE,mBAIdC,QAAA,EACAC,UAAA,EAGQ;EACJ,IAAAC,WAAA;EACA,IAAAC,IAAA;EACA,IAAAP,KAAA;EAEJ,MAAMQ,IAAA,GAAOA,CAAA,KAAM;IACjB,IAAI,CAACF,WAAA,EAAa;MAChBA,WAAA,GAAcF,QAAA,CAAS,EACpBK,IAAA,CAAMC,GAAA,IAAQ;QACCJ,WAAA;QACPC,IAAA,GAAAG,GAAA,CAAIL,UAAA,IAAc,SAAS;MAAA,CACnC,EACAM,KAAA,CAAOC,GAAA,IAAQ;QACNZ,KAAA,GAAAY,GAAA;MAAA,CACT;IACL;IAEO,OAAAN,WAAA;EAAA;EAGH,MAAAO,QAAA,GAAW,SAASC,KAAKC,KAAA,EAAY;IAGzC,IAAIf,KAAA,EAAO;MACL,IAAAD,qBAAA,CAAsBC,KAAK,GAAG;QAMhC,IACEA,KAAA,YAAiBgB,KAAA,IACjB,OAAOC,MAAA,KAAW,eAClB,OAAOC,cAAA,KAAmB,aAC1B;UAKM,MAAAC,UAAA,GAAa,0BAA0BnB,KAAA,CAAMC,OAAO;UAC1D,IAAI,CAACiB,cAAA,CAAeE,OAAA,CAAQD,UAAU,GAAG;YACxBD,cAAA,CAAAG,OAAA,CAAQF,UAAA,EAAY,GAAG;YACtCF,MAAA,CAAOK,QAAA,CAASC,MAAA;YAGT;cACLC,OAAA,EAASA,CAAA,KAAM;YAAA;UAEnB;QACF;MACF;MAGM,MAAAxB,KAAA;IACR;IAEA,IAAI,CAACO,IAAA,EAAM;MACT,MAAMC,IAAA,CAAK;IACb;IAEO,OAAAiB,KAAA,CAAMC,aAAA,CAAcnB,IAAA,EAAMQ,KAAK;EAAA;EAGtCF,QAAA,CAAiBc,OAAA,GAAUnB,IAAA;EAEtB,OAAAK,QAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}