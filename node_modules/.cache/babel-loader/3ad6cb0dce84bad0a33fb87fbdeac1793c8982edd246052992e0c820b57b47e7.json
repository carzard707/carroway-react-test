{"ast":null,"code":"import * as React from \"react\";\nimport { pick, usePrevious, useLayoutEffect } from \"./utils.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { trimPathRight } from \"./path.js\";\nfunction Transitioner() {\n  const router = useRouter();\n  const mountLoadForRouter = React.useRef({\n    router,\n    mounted: false\n  });\n  const routerState = useRouterState({\n    select: s => pick(s, [\"isLoading\", \"location\", \"resolvedLocation\", \"isTransitioning\"])\n  });\n  const [isTransitioning, startReactTransition_] = React.useTransition();\n  const hasPendingMatches = useRouterState({\n    select: s => s.matches.some(d => d.status === \"pending\")\n  });\n  const previousIsLoading = usePrevious(routerState.isLoading);\n  const isAnyPending = routerState.isLoading || isTransitioning || hasPendingMatches;\n  const previousIsAnyPending = usePrevious(isAnyPending);\n  if (!router.isServer) {\n    router.startReactTransition = startReactTransition_;\n  }\n  React.useEffect(() => {\n    const unsub = router.history.subscribe(router.load);\n    const nextLocation = router.buildLocation({\n      to: router.latestLocation.pathname,\n      search: true,\n      params: true,\n      hash: true,\n      state: true\n    });\n    if (trimPathRight(router.latestLocation.href) !== trimPathRight(nextLocation.href)) {\n      router.commitLocation({\n        ...nextLocation,\n        replace: true\n      });\n    }\n    return () => {\n      unsub();\n    };\n  }, [router, router.history]);\n  useLayoutEffect(() => {\n    var _a;\n    if (typeof window !== \"undefined\" && ((_a = window.__TSR__) == null ? void 0 : _a.dehydrated) || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted) {\n      return;\n    }\n    mountLoadForRouter.current = {\n      router,\n      mounted: true\n    };\n    const tryLoad = async () => {\n      try {\n        await router.load();\n      } catch (err) {\n        console.error(err);\n      }\n    };\n    tryLoad();\n  }, [router]);\n  useLayoutEffect(() => {\n    if (previousIsLoading && !routerState.isLoading) {\n      const toLocation = router.state.location;\n      const fromLocation = router.state.resolvedLocation;\n      const pathChanged = fromLocation.href !== toLocation.href;\n      router.emit({\n        type: \"onLoad\",\n        // When the new URL has committed, when the new matches have been loaded into state.matches\n        fromLocation,\n        toLocation,\n        pathChanged\n      });\n    }\n  }, [previousIsLoading, router, routerState.isLoading]);\n  useLayoutEffect(() => {\n    if (previousIsAnyPending && !isAnyPending) {\n      const toLocation = router.state.location;\n      const fromLocation = router.state.resolvedLocation;\n      const pathChanged = fromLocation.href !== toLocation.href;\n      router.emit({\n        type: \"onResolved\",\n        fromLocation,\n        toLocation,\n        pathChanged\n      });\n      router.__store.setState(s => ({\n        ...s,\n        status: \"idle\",\n        resolvedLocation: s.location\n      }));\n      if (typeof document !== \"undefined\" && document.querySelector) {\n        if (router.state.location.hash !== \"\") {\n          const el = document.getElementById(router.state.location.hash);\n          if (el) {\n            el.scrollIntoView();\n          }\n        }\n      }\n    }\n  }, [isAnyPending, previousIsAnyPending, router]);\n  return null;\n}\nexport { Transitioner };","map":{"version":3,"names":["Transitioner","router","useRouter","mountLoadForRouter","React","useRef","mounted","routerState","useRouterState","select","s","pick","isTransitioning","startReactTransition_","useTransition","hasPendingMatches","matches","some","d","status","previousIsLoading","usePrevious","isLoading","isAnyPending","previousIsAnyPending","isServer","startReactTransition","useEffect","unsub","history","subscribe","load","nextLocation","buildLocation","to","latestLocation","pathname","search","params","hash","state","trimPathRight","href","commitLocation","replace","useLayoutEffect","window","_a","__TSR__","dehydrated","current","tryLoad","err","console","error","toLocation","location","fromLocation","resolvedLocation","pathChanged","emit","type","__store","setState","document","querySelector","el","getElementById","scrollIntoView"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react-test/carroway-react-test/node_modules/@tanstack/react-router/src/Transitioner.tsx"],"sourcesContent":["import * as React from 'react'\nimport { pick, useLayoutEffect, usePrevious } from './utils'\nimport { useRouter } from './useRouter'\nimport { useRouterState } from './useRouterState'\nimport { trimPathRight } from './path'\n\nexport function Transitioner() {\n  const router = useRouter()\n  const mountLoadForRouter = React.useRef({ router, mounted: false })\n  const routerState = useRouterState({\n    select: (s) =>\n      pick(s, ['isLoading', 'location', 'resolvedLocation', 'isTransitioning']),\n  })\n\n  const [isTransitioning, startReactTransition_] = React.useTransition()\n  // Track pending state changes\n  const hasPendingMatches = useRouterState({\n    select: (s) => s.matches.some((d) => d.status === 'pending'),\n  })\n\n  const previousIsLoading = usePrevious(routerState.isLoading)\n\n  const isAnyPending =\n    routerState.isLoading || isTransitioning || hasPendingMatches\n  const previousIsAnyPending = usePrevious(isAnyPending)\n\n  if (!router.isServer) {\n    router.startReactTransition = startReactTransition_\n  }\n\n  // Subscribe to location changes\n  // and try to load the new location\n  React.useEffect(() => {\n    const unsub = router.history.subscribe(router.load)\n\n    const nextLocation = router.buildLocation({\n      to: router.latestLocation.pathname,\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (\n      trimPathRight(router.latestLocation.href) !==\n      trimPathRight(nextLocation.href)\n    ) {\n      router.commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [router, router.history])\n\n  // Try to load the initial location\n  useLayoutEffect(() => {\n    if (\n      (typeof window !== 'undefined' && window.__TSR__?.dehydrated) ||\n      (mountLoadForRouter.current.router === router &&\n        mountLoadForRouter.current.mounted)\n    ) {\n      return\n    }\n    mountLoadForRouter.current = { router, mounted: true }\n\n    const tryLoad = async () => {\n      try {\n        await router.load()\n      } catch (err) {\n        console.error(err)\n      }\n    }\n\n    tryLoad()\n  }, [router])\n\n  useLayoutEffect(() => {\n    // The router was loading and now it's not\n    if (previousIsLoading && !routerState.isLoading) {\n      const toLocation = router.state.location\n      const fromLocation = router.state.resolvedLocation\n      const pathChanged = fromLocation.href !== toLocation.href\n\n      router.emit({\n        type: 'onLoad', // When the new URL has committed, when the new matches have been loaded into state.matches\n        fromLocation,\n        toLocation,\n        pathChanged,\n      })\n    }\n  }, [previousIsLoading, router, routerState.isLoading])\n\n  useLayoutEffect(() => {\n    // The router was pending and now it's not\n    if (previousIsAnyPending && !isAnyPending) {\n      const toLocation = router.state.location\n      const fromLocation = router.state.resolvedLocation\n      const pathChanged = fromLocation.href !== toLocation.href\n\n      router.emit({\n        type: 'onResolved',\n        fromLocation,\n        toLocation,\n        pathChanged,\n      })\n\n      router.__store.setState((s) => ({\n        ...s,\n        status: 'idle',\n        resolvedLocation: s.location,\n      }))\n\n      if (typeof document !== 'undefined' && (document as any).querySelector) {\n        if (router.state.location.hash !== '') {\n          const el = document.getElementById(router.state.location.hash)\n          if (el) {\n            el.scrollIntoView()\n          }\n        }\n      }\n    }\n  }, [isAnyPending, previousIsAnyPending, router])\n\n  return null\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}