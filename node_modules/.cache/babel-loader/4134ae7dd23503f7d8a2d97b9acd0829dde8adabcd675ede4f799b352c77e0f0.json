{"ast":null,"code":"import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nimport { functionalUpdate } from \"./utils.js\";\nconst useLayoutEffect = typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst windowKey = \"window\";\nconst delimiter = \"___\";\nlet weakScrolledElements = /* @__PURE__ */new WeakSet();\nconst sessionsStorage = typeof window !== \"undefined\" && window.sessionStorage;\nconst cache = sessionsStorage ? (() => {\n  const storageKey = \"tsr-scroll-restoration-v2\";\n  const state = JSON.parse(window.sessionStorage.getItem(storageKey) || \"null\") || {\n    cached: {},\n    next: {}\n  };\n  return {\n    state,\n    set: updater => {\n      cache.state = functionalUpdate(updater, cache.state);\n      window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));\n    }\n  };\n})() : void 0;\nconst defaultGetKey = location => {\n  return location.state.key || location.href;\n};\nfunction useScrollRestoration(options) {\n  const router = useRouter();\n  useLayoutEffect(() => {\n    const getKey = (options == null ? void 0 : options.getKey) || defaultGetKey;\n    const {\n      history\n    } = window;\n    history.scrollRestoration = \"manual\";\n    const onScroll = event => {\n      if (weakScrolledElements.has(event.target)) return;\n      weakScrolledElements.add(event.target);\n      let elementSelector = \"\";\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey;\n      } else {\n        const attrId = event.target.getAttribute(\"data-scroll-restoration-id\");\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`;\n        } else {\n          elementSelector = getCssSelector(event.target);\n        }\n      }\n      if (!cache.state.next[elementSelector]) {\n        cache.set(c => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN\n            }\n          }\n        }));\n      }\n    };\n    if (typeof document !== \"undefined\") {\n      document.addEventListener(\"scroll\", onScroll, true);\n    }\n    const unsubOnBeforeLoad = router.subscribe(\"onBeforeLoad\", event => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation);\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector];\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0;\n            entry.scrollY = window.scrollY || 0;\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector);\n            entry.scrollX = (element == null ? void 0 : element.scrollLeft) || 0;\n            entry.scrollY = (element == null ? void 0 : element.scrollTop) || 0;\n          }\n          cache.set(c => {\n            const next = {\n              ...c.next\n            };\n            delete next[elementSelector];\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry\n              }\n            };\n          });\n        }\n      }\n    });\n    const unsubOnResolved = router.subscribe(\"onResolved\", event => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return;\n        }\n        router.resetNextScroll = true;\n        const restoreKey = getKey(event.toLocation);\n        let windowRestored = false;\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey];\n          const [key, elementSelector] = cacheKey.split(delimiter);\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true;\n              window.scrollTo(entry.scrollX, entry.scrollY);\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector);\n              if (element) {\n                element.scrollLeft = entry.scrollX;\n                element.scrollTop = entry.scrollY;\n              }\n            }\n          }\n        }\n        if (!windowRestored) {\n          window.scrollTo(0, 0);\n        }\n        cache.set(c => ({\n          ...c,\n          next: {}\n        }));\n        weakScrolledElements = /* @__PURE__ */new WeakSet();\n      }\n    });\n    return () => {\n      document.removeEventListener(\"scroll\", onScroll);\n      unsubOnBeforeLoad();\n      unsubOnResolved();\n    };\n  }, [options == null ? void 0 : options.getKey, router]);\n}\nfunction ScrollRestoration(props) {\n  useScrollRestoration(props);\n  return null;\n}\nfunction useElementScrollRestoration(options) {\n  var _a;\n  const router = useRouter();\n  const getKey = options.getKey || defaultGetKey;\n  let elementSelector = \"\";\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`;\n  } else {\n    const element = (_a = options.getElement) == null ? void 0 : _a.call(options);\n    if (!element) {\n      return;\n    }\n    elementSelector = getCssSelector(element);\n  }\n  const restoreKey = getKey(router.latestLocation);\n  const cacheKey = [restoreKey, elementSelector].join(delimiter);\n  return cache.state.cached[cacheKey];\n}\nfunction getCssSelector(el) {\n  const path = [];\n  let parent;\n  while (parent = el.parentNode) {\n    path.unshift(`${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`);\n    el = parent;\n  }\n  return `${path.join(\" > \")}`.toLowerCase();\n}\nexport { ScrollRestoration, useElementScrollRestoration, useScrollRestoration };","map":{"version":3,"names":["useLayoutEffect","window","React","useEffect","windowKey","delimiter","weakScrolledElements","WeakSet","sessionsStorage","sessionStorage","cache","storageKey","state","JSON","parse","getItem","cached","next","set","updater","functionalUpdate","setItem","stringify","defaultGetKey","location","key","href","useScrollRestoration","options","router","useRouter","getKey","history","scrollRestoration","onScroll","event","has","target","add","elementSelector","document","attrId","getAttribute","getCssSelector","c","scrollX","NaN","scrollY","addEventListener","unsubOnBeforeLoad","subscribe","pathChanged","restoreKey","fromLocation","entry","element","querySelector","scrollLeft","scrollTop","join","unsubOnResolved","resetNextScroll","toLocation","windowRestored","cacheKey","split","scrollTo","removeEventListener","ScrollRestoration","props","useElementScrollRestoration","id","_a","getElement","call","latestLocation","el","path","parent","parentNode","unshift","tagName","indexOf","children","toLowerCase"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react/node_modules/@tanstack/react-router/src/scroll-restoration.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport { functionalUpdate } from './utils'\nimport type { ParsedLocation } from './location'\nimport type { NonNullableUpdater } from './utils'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nconst cache: Cache = sessionsStorage\n  ? (() => {\n      const storageKey = 'tsr-scroll-restoration-v2'\n\n      const state: CacheState = JSON.parse(\n        window.sessionStorage.getItem(storageKey) || 'null',\n      ) || { cached: {}, next: {} }\n\n      return {\n        state,\n        set: (updater) => {\n          cache.state = functionalUpdate(updater, cache.state)\n          window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state))\n        },\n      }\n    })()\n  : (undefined as any)\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\n/**\n * The default `getKey` function for `useScrollRestoration`.\n * It returns the `key` from the location state or the `href` of the location.\n *\n * The `location.href` is used as a fallback to support the use case where the location state is not available like the initial render.\n */\nconst defaultGetKey = (location: ParsedLocation) => {\n  return location.state.key! || location.href\n}\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const router = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    const { history } = window\n    history.scrollRestoration = 'manual'\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      let elementSelector = ''\n\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey\n      } else {\n        const attrId = (event.target as Element).getAttribute(\n          'data-scroll-restoration-id',\n        )\n\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n        } else {\n          elementSelector = getCssSelector(event.target)\n        }\n      }\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = router.subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return\n        }\n\n        router.resetNextScroll = true\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [options?.getKey, router])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n\nexport function useElementScrollRestoration(\n  options: (\n    | {\n        id: string\n        getElement?: () => Element | undefined | null\n      }\n    | {\n        id?: string\n        getElement: () => Element | undefined | null\n      }\n  ) & {\n    getKey?: (location: ParsedLocation) => string\n  },\n) {\n  const router = useRouter()\n  const getKey = options.getKey || defaultGetKey\n\n  let elementSelector = ''\n\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`\n  } else {\n    const element = options.getElement?.()\n    if (!element) {\n      return\n    }\n    elementSelector = getCssSelector(element)\n  }\n\n  const restoreKey = getKey(router.latestLocation)\n  const cacheKey = [restoreKey, elementSelector].join(delimiter)\n  return cache.state.cached[cacheKey]\n}\n\nfunction getCssSelector(el: any): string {\n  const path = []\n  let parent\n  while ((parent = el.parentNode)) {\n    path.unshift(\n      `${el.tagName}:nth-child(${\n        ([].indexOf as any).call(parent.children, el) + 1\n      })`,\n    )\n    el = parent\n  }\n  return `${path.join(' > ')}`.toLowerCase()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}