{"ast":null,"code":"import { createMemoryHistory, createBrowserHistory, parseHref } from \"@tanstack/history\";\nimport { Store } from \"@tanstack/react-store\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\nimport { rootRouteId } from \"./root.js\";\nimport { defaultStringifySearch, defaultParseSearch } from \"./searchParams.js\";\nimport { pick, createControlledPromise, deepEqual, replaceEqualDeep, last, functionalUpdate } from \"./utils.js\";\nimport { trimPath, trimPathLeft, parsePathname, resolvePath, cleanPath, matchPathname, trimPathRight, interpolatePath, joinPaths } from \"./path.js\";\nimport { isResolvedRedirect, isRedirect } from \"./redirects.js\";\nimport { isNotFound } from \"./not-found.js\";\nimport { defaultTransformer } from \"./transformer.js\";\nconst componentTypes = [\"component\", \"errorComponent\", \"pendingComponent\", \"notFoundComponent\"];\nfunction createRouter(options) {\n  return new Router(options);\n}\nclass Router {\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(options) {\n    var _this = this;\n    this.tempLocationKey = `${Math.round(Math.random() * 1e7)}`;\n    this.resetNextScroll = true;\n    this.shouldViewTransition = void 0;\n    this.subscribers = /* @__PURE__ */new Set();\n    this.startReactTransition = fn => fn();\n    this.update = newOptions => {\n      if (newOptions.notFoundRoute) {\n        console.warn(\"The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\");\n      }\n      const previousOptions = this.options;\n      this.options = {\n        ...this.options,\n        ...newOptions\n      };\n      this.isServer = this.options.isServer ?? typeof document === \"undefined\";\n      if (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) {\n        if (newOptions.basepath === void 0 || newOptions.basepath === \"\" || newOptions.basepath === \"/\") {\n          this.basepath = \"/\";\n        } else {\n          this.basepath = `/${trimPath(newOptions.basepath)}`;\n        }\n      }\n      if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      !this.history || this.options.history && this.options.history !== this.history) {\n        this.history = this.options.history ?? (this.isServer ? createMemoryHistory({\n          initialEntries: [this.basepath || \"/\"]\n        }) : createBrowserHistory());\n        this.latestLocation = this.parseLocation();\n      }\n      if (this.options.routeTree !== this.routeTree) {\n        this.routeTree = this.options.routeTree;\n        this.buildRouteTree();\n      }\n      if (!this.__store) {\n        this.__store = new Store(getInitialRouterState(this.latestLocation), {\n          onUpdate: () => {\n            this.__store.state = {\n              ...this.state,\n              cachedMatches: this.state.cachedMatches.filter(d => ![\"redirected\"].includes(d.status))\n            };\n          }\n        });\n      }\n    };\n    this.buildRouteTree = () => {\n      this.routesById = {};\n      this.routesByPath = {};\n      const notFoundRoute = this.options.notFoundRoute;\n      if (notFoundRoute) {\n        notFoundRoute.init({\n          originalIndex: 99999999999\n        });\n        this.routesById[notFoundRoute.id] = notFoundRoute;\n      }\n      const recurseRoutes = childRoutes => {\n        childRoutes.forEach((childRoute, i) => {\n          childRoute.init({\n            originalIndex: i\n          });\n          const existingRoute = this.routesById[childRoute.id];\n          invariant(!existingRoute, `Duplicate routes found with id: ${String(childRoute.id)}`);\n          this.routesById[childRoute.id] = childRoute;\n          if (!childRoute.isRoot && childRoute.path) {\n            const trimmedFullPath = trimPathRight(childRoute.fullPath);\n            if (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith(\"/\")) {\n              this.routesByPath[trimmedFullPath] = childRoute;\n            }\n          }\n          const children = childRoute.children;\n          if (children == null ? void 0 : children.length) {\n            recurseRoutes(children);\n          }\n        });\n      };\n      recurseRoutes([this.routeTree]);\n      const scoredRoutes = [];\n      const routes = Object.values(this.routesById);\n      routes.forEach((d, i) => {\n        var _a;\n        if (d.isRoot || !d.path) {\n          return;\n        }\n        const trimmed = trimPathLeft(d.fullPath);\n        const parsed = parsePathname(trimmed);\n        while (parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === \"/\") {\n          parsed.shift();\n        }\n        const scores = parsed.map(segment => {\n          if (segment.value === \"/\") {\n            return 0.75;\n          }\n          if (segment.type === \"param\") {\n            return 0.5;\n          }\n          if (segment.type === \"wildcard\") {\n            return 0.25;\n          }\n          return 1;\n        });\n        scoredRoutes.push({\n          child: d,\n          trimmed,\n          parsed,\n          index: i,\n          scores\n        });\n      });\n      this.flatRoutes = scoredRoutes.sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length);\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i] - a.scores[i];\n          }\n        }\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length;\n        }\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i].value !== b.parsed[i].value) {\n            return a.parsed[i].value > b.parsed[i].value ? 1 : -1;\n          }\n        }\n        return a.index - b.index;\n      }).map((d, i) => {\n        d.child.rank = i;\n        return d.child;\n      });\n    };\n    this.subscribe = (eventType, fn) => {\n      const listener = {\n        eventType,\n        fn\n      };\n      this.subscribers.add(listener);\n      return () => {\n        this.subscribers.delete(listener);\n      };\n    };\n    this.emit = routerEvent => {\n      this.subscribers.forEach(listener => {\n        if (listener.eventType === routerEvent.type) {\n          listener.fn(routerEvent);\n        }\n      });\n    };\n    this.parseLocation = previousLocation => {\n      const parse = _ref => {\n        let {\n          pathname,\n          search,\n          hash,\n          state\n        } = _ref;\n        const parsedSearch = this.options.parseSearch(search);\n        const searchStr = this.options.stringifySearch(parsedSearch);\n        return {\n          pathname,\n          searchStr,\n          search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),\n          hash: hash.split(\"#\").reverse()[0] ?? \"\",\n          href: `${pathname}${searchStr}${hash}`,\n          state: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.state, state)\n        };\n      };\n      const location = parse(this.history.location);\n      const {\n        __tempLocation,\n        __tempKey\n      } = location.state;\n      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n        const parsedTempLocation = parse(__tempLocation);\n        parsedTempLocation.state.key = location.state.key;\n        delete parsedTempLocation.state.__tempLocation;\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location\n        };\n      }\n      return location;\n    };\n    this.resolvePathWithBase = (from, path) => {\n      const resolvedPath = resolvePath({\n        basepath: this.basepath,\n        base: from,\n        to: cleanPath(path),\n        trailingSlash: this.options.trailingSlash\n      });\n      return resolvedPath;\n    };\n    this.cancelMatch = id => {\n      const match = this.getMatch(id);\n      if (!match) return;\n      match.abortController.abort();\n      clearTimeout(match.pendingTimeout);\n    };\n    this.cancelMatches = () => {\n      var _a;\n      (_a = this.state.pendingMatches) == null ? void 0 : _a.forEach(match => {\n        this.cancelMatch(match.id);\n      });\n    };\n    this.buildLocation = opts => {\n      const build = function () {\n        let dest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let matches = arguments.length > 1 ? arguments[1] : undefined;\n        var _a, _b, _c;\n        const fromMatches = dest._fromLocation != null ? _this.matchRoutes({\n          ...dest._fromLocation,\n          search: dest.fromSearch || dest._fromLocation.search\n        }) : _this.state.matches;\n        const fromMatch = dest.from != null ? fromMatches.find(d => matchPathname(_this.basepath, trimPathRight(d.pathname), {\n          to: dest.from,\n          caseSensitive: false,\n          fuzzy: false\n        })) : void 0;\n        const fromPath = (fromMatch == null ? void 0 : fromMatch.pathname) || _this.latestLocation.pathname;\n        invariant(dest.from == null || fromMatch != null, \"Could not find match for from: \" + dest.from);\n        const fromSearch = ((_a = last(fromMatches)) == null ? void 0 : _a.search) || _this.latestLocation.search;\n        const stayingMatches = matches == null ? void 0 : matches.filter(d => fromMatches.find(e => e.routeId === d.routeId));\n        const fromRouteByFromPathRouteId = _this.routesById[(_b = stayingMatches == null ? void 0 : stayingMatches.find(d => d.pathname === fromPath)) == null ? void 0 : _b.routeId];\n        let pathname = dest.to ? _this.resolvePathWithBase(fromPath, `${dest.to}`) : _this.resolvePathWithBase(fromPath, (fromRouteByFromPathRouteId == null ? void 0 : fromRouteByFromPathRouteId.to) ?? fromPath);\n        const prevParams = {\n          ...((_c = last(fromMatches)) == null ? void 0 : _c.params)\n        };\n        let nextParams = (dest.params ?? true) === true ? prevParams : {\n          ...prevParams,\n          ...functionalUpdate(dest.params, prevParams)\n        };\n        if (Object.keys(nextParams).length > 0) {\n          matches == null ? void 0 : matches.map(d => {\n            var _a2;\n            const route = _this.looseRoutesById[d.routeId];\n            return ((_a2 = route == null ? void 0 : route.options.params) == null ? void 0 : _a2.stringify) ?? route.options.stringifyParams;\n          }).filter(Boolean).forEach(fn => {\n            nextParams = {\n              ...nextParams,\n              ...fn(nextParams)\n            };\n          });\n        }\n        pathname = interpolatePath({\n          path: pathname,\n          params: nextParams ?? {},\n          leaveWildcards: false,\n          leaveParams: opts.leaveParams\n        });\n        const preSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map(match => _this.looseRoutesById[match.routeId].options.preSearchFilters ?? []).flat().filter(Boolean)) ?? [];\n        const postSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map(match => _this.looseRoutesById[match.routeId].options.postSearchFilters ?? []).flat().filter(Boolean)) ?? [];\n        const preFilteredSearch = preSearchFilters.length ? preSearchFilters.reduce((prev, next) => next(prev), fromSearch) : fromSearch;\n        const destSearch = dest.search === true ? preFilteredSearch : dest.search ? functionalUpdate(dest.search, preFilteredSearch) : preSearchFilters.length ? preFilteredSearch : {};\n        const postFilteredSearch = postSearchFilters.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;\n        const search = replaceEqualDeep(fromSearch, postFilteredSearch);\n        const searchStr = _this.options.stringifySearch(search);\n        const hash = dest.hash === true ? _this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, _this.latestLocation.hash) : void 0;\n        const hashStr = hash ? `#${hash}` : \"\";\n        let nextState = dest.state === true ? _this.latestLocation.state : dest.state ? functionalUpdate(dest.state, _this.latestLocation.state) : {};\n        nextState = replaceEqualDeep(_this.latestLocation.state, nextState);\n        return {\n          pathname,\n          search,\n          searchStr,\n          state: nextState,\n          hash: hash ?? \"\",\n          href: `${pathname}${searchStr}${hashStr}`,\n          unmaskOnReload: dest.unmaskOnReload\n        };\n      };\n      const buildWithMatches = function () {\n        let dest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let maskedDest = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        const next = build(dest);\n        let maskedNext = maskedDest ? build(maskedDest) : void 0;\n        if (!maskedNext) {\n          let params = {};\n          const foundMask = (_a = _this.options.routeMasks) == null ? void 0 : _a.find(d => {\n            const match = matchPathname(_this.basepath, next.pathname, {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false\n            });\n            if (match) {\n              params = match;\n              return true;\n            }\n            return false;\n          });\n          if (foundMask) {\n            const {\n              from,\n              ...maskProps\n            } = foundMask;\n            maskedDest = {\n              ...pick(opts, [\"from\"]),\n              ...maskProps,\n              params\n            };\n            maskedNext = build(maskedDest);\n          }\n        }\n        const nextMatches = _this.matchRoutes(next);\n        const maskedMatches = maskedNext ? _this.matchRoutes(maskedNext) : void 0;\n        const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : void 0;\n        const final = build(dest, nextMatches);\n        if (maskedFinal) {\n          final.maskedLocation = maskedFinal;\n        }\n        return final;\n      };\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          ...pick(opts, [\"from\"]),\n          ...opts.mask\n        });\n      }\n      return buildWithMatches(opts);\n    };\n    this.commitLocation = _ref2 => {\n      let {\n        viewTransition,\n        ignoreBlocker,\n        ...next\n      } = _ref2;\n      const isSameState = () => {\n        next.state.key = this.latestLocation.state.key;\n        const isEqual = deepEqual(next.state, this.latestLocation.state);\n        delete next.state.key;\n        return isEqual;\n      };\n      const isSameUrl = this.latestLocation.href === next.href;\n      const previousCommitPromise = this.commitLocationPromise;\n      this.commitLocationPromise = createControlledPromise(() => {\n        previousCommitPromise == null ? void 0 : previousCommitPromise.resolve();\n      });\n      if (isSameUrl && isSameState()) {\n        this.load();\n      } else {\n        let {\n          maskedLocation,\n          ...nextHistory\n        } = next;\n        if (maskedLocation) {\n          nextHistory = {\n            ...maskedLocation,\n            state: {\n              ...maskedLocation.state,\n              __tempKey: void 0,\n              __tempLocation: {\n                ...nextHistory,\n                search: nextHistory.searchStr,\n                state: {\n                  ...nextHistory.state,\n                  __tempKey: void 0,\n                  __tempLocation: void 0,\n                  key: void 0\n                }\n              }\n            }\n          };\n          if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {\n            nextHistory.state.__tempKey = this.tempLocationKey;\n          }\n        }\n        this.shouldViewTransition = viewTransition;\n        this.history[next.replace ? \"replace\" : \"push\"](nextHistory.href, nextHistory.state, {\n          ignoreBlocker\n        });\n      }\n      this.resetNextScroll = next.resetScroll ?? true;\n      if (!this.history.subscribers.size) {\n        this.load();\n      }\n      return this.commitLocationPromise;\n    };\n    this.buildAndCommitLocation = function () {\n      let {\n        replace,\n        resetScroll,\n        viewTransition,\n        ignoreBlocker,\n        ...rest\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const href = rest.href;\n      if (href) {\n        const parsed = parseHref(href, {});\n        rest.to = parsed.pathname;\n        rest.search = _this.options.parseSearch(parsed.search);\n        rest.hash = parsed.hash;\n      }\n      const location = _this.buildLocation(rest);\n      return _this.commitLocation({\n        ...location,\n        viewTransition,\n        replace,\n        resetScroll,\n        ignoreBlocker\n      });\n    };\n    this.navigate = _ref3 => {\n      let {\n        to,\n        __isRedirect,\n        ...rest\n      } = _ref3;\n      const toString = String(to);\n      let isExternal;\n      try {\n        new URL(`${toString}`);\n        isExternal = true;\n      } catch (e) {}\n      invariant(!isExternal, \"Attempting to navigate to external url with router.navigate!\");\n      return this.buildAndCommitLocation({\n        ...rest,\n        to\n        // to: toString,\n      });\n    };\n    this.load = async () => {\n      this.latestLocation = this.parseLocation(this.latestLocation);\n      this.__store.setState(s => ({\n        ...s,\n        loadedAt: Date.now()\n      }));\n      let redirect;\n      let notFound;\n      let loadPromise;\n      loadPromise = new Promise(resolve => {\n        this.startReactTransition(async () => {\n          var _a;\n          try {\n            const next = this.latestLocation;\n            const prevLocation = this.state.resolvedLocation;\n            const pathDidChange = prevLocation.href !== next.href;\n            this.cancelMatches();\n            let pendingMatches;\n            this.__store.batch(() => {\n              pendingMatches = this.matchRoutes(next);\n              this.__store.setState(s => ({\n                ...s,\n                status: \"pending\",\n                isLoading: true,\n                location: next,\n                pendingMatches,\n                // If a cached moved to pendingMatches, remove it from cachedMatches\n                cachedMatches: s.cachedMatches.filter(d => {\n                  return !pendingMatches.find(e => e.id === d.id);\n                })\n              }));\n            });\n            if (!this.state.redirect) {\n              this.emit({\n                type: \"onBeforeNavigate\",\n                fromLocation: prevLocation,\n                toLocation: next,\n                pathChanged: pathDidChange\n              });\n            }\n            this.emit({\n              type: \"onBeforeLoad\",\n              fromLocation: prevLocation,\n              toLocation: next,\n              pathChanged: pathDidChange\n            });\n            await this.loadMatches({\n              matches: pendingMatches,\n              location: next,\n              // eslint-disable-next-line @typescript-eslint/require-await\n              onReady: async () => {\n                this.startViewTransition(async () => {\n                  let exitingMatches;\n                  let enteringMatches;\n                  let stayingMatches;\n                  this.__store.batch(() => {\n                    this.__store.setState(s => {\n                      const previousMatches = s.matches;\n                      const newMatches = s.pendingMatches || s.matches;\n                      exitingMatches = previousMatches.filter(match => !newMatches.find(d => d.id === match.id));\n                      enteringMatches = newMatches.filter(match => !previousMatches.find(d => d.id === match.id));\n                      stayingMatches = previousMatches.filter(match => newMatches.find(d => d.id === match.id));\n                      return {\n                        ...s,\n                        isLoading: false,\n                        matches: newMatches,\n                        pendingMatches: void 0,\n                        cachedMatches: [...s.cachedMatches, ...exitingMatches.filter(d => d.status !== \"error\")]\n                      };\n                    });\n                    this.cleanCache();\n                  });\n                  [[exitingMatches, \"onLeave\"], [enteringMatches, \"onEnter\"], [stayingMatches, \"onStay\"]].forEach(_ref4 => {\n                    let [matches, hook] = _ref4;\n                    matches.forEach(match => {\n                      var _a2, _b;\n                      (_b = (_a2 = this.looseRoutesById[match.routeId].options)[hook]) == null ? void 0 : _b.call(_a2, match);\n                    });\n                  });\n                });\n              }\n            });\n          } catch (err) {\n            if (isResolvedRedirect(err)) {\n              redirect = err;\n              if (!this.isServer) {\n                this.navigate({\n                  ...err,\n                  replace: true,\n                  __isRedirect: true\n                });\n              }\n            } else if (isNotFound(err)) {\n              notFound = err;\n            }\n            this.__store.setState(s => ({\n              ...s,\n              statusCode: redirect ? redirect.statusCode : notFound ? 404 : s.matches.some(d => d.status === \"error\") ? 500 : 200,\n              redirect\n            }));\n          }\n          if (this.latestLoadPromise === loadPromise) {\n            (_a = this.commitLocationPromise) == null ? void 0 : _a.resolve();\n            this.latestLoadPromise = void 0;\n            this.commitLocationPromise = void 0;\n          }\n          resolve();\n        });\n      });\n      this.latestLoadPromise = loadPromise;\n      await loadPromise;\n      while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) {\n        await this.latestLoadPromise;\n      }\n    };\n    this.startViewTransition = fn => {\n      var _a, _b;\n      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;\n      delete this.shouldViewTransition;\n      ((_b = (_a = shouldViewTransition && typeof document !== \"undefined\" ? document : void 0) == null ? void 0 : _a.startViewTransition) == null ? void 0 : _b.call(_a, fn)) || fn();\n    };\n    this.updateMatch = (id, updater) => {\n      var _a;\n      let updated;\n      const isPending = (_a = this.state.pendingMatches) == null ? void 0 : _a.find(d => d.id === id);\n      const isMatched = this.state.matches.find(d => d.id === id);\n      const matchesKey = isPending ? \"pendingMatches\" : isMatched ? \"matches\" : \"cachedMatches\";\n      this.__store.setState(s => {\n        var _a2;\n        return {\n          ...s,\n          [matchesKey]: (_a2 = s[matchesKey]) == null ? void 0 : _a2.map(d => d.id === id ? updated = updater(d) : d)\n        };\n      });\n      return updated;\n    };\n    this.getMatch = matchId => {\n      return [...this.state.cachedMatches, ...(this.state.pendingMatches ?? []), ...this.state.matches].find(d => d.id === matchId);\n    };\n    this.loadMatches = async _ref5 => {\n      let {\n        location,\n        matches,\n        preload,\n        onReady,\n        updateMatch = this.updateMatch\n      } = _ref5;\n      let firstBadMatchIndex;\n      let rendered = false;\n      const triggerOnReady = async () => {\n        if (!rendered) {\n          rendered = true;\n          await (onReady == null ? void 0 : onReady());\n        }\n      };\n      if (!this.isServer && !this.state.matches.length) {\n        triggerOnReady();\n      }\n      const handleRedirectAndNotFound = (match, err) => {\n        var _a, _b, _c;\n        if (isResolvedRedirect(err)) throw err;\n        if (isRedirect(err) || isNotFound(err)) {\n          updateMatch(match.id, prev => ({\n            ...prev,\n            status: isRedirect(err) ? \"redirected\" : isNotFound(err) ? \"notFound\" : \"error\",\n            isFetching: false,\n            error: err,\n            beforeLoadPromise: void 0,\n            loaderPromise: void 0\n          }));\n          if (!err.routeId) {\n            err.routeId = match.routeId;\n          }\n          (_a = match.beforeLoadPromise) == null ? void 0 : _a.resolve();\n          (_b = match.loaderPromise) == null ? void 0 : _b.resolve();\n          (_c = match.loadPromise) == null ? void 0 : _c.resolve();\n          if (isRedirect(err)) {\n            rendered = true;\n            err = this.resolveRedirect({\n              ...err,\n              _fromLocation: location\n            });\n            throw err;\n          } else if (isNotFound(err)) {\n            this._handleNotFound(matches, err, {\n              updateMatch\n            });\n            throw err;\n          }\n        }\n      };\n      try {\n        await new Promise((resolveAll, rejectAll) => {\n          ;\n          (async () => {\n            var _a, _b, _c;\n            try {\n              const handleSerialError = (index, err, routerCode) => {\n                var _a2, _b2;\n                const {\n                  id: matchId,\n                  routeId\n                } = matches[index];\n                const route = this.looseRoutesById[routeId];\n                if (err instanceof Promise) {\n                  throw err;\n                }\n                err.routerCode = routerCode;\n                firstBadMatchIndex = firstBadMatchIndex ?? index;\n                handleRedirectAndNotFound(this.getMatch(matchId), err);\n                try {\n                  (_b2 = (_a2 = route.options).onError) == null ? void 0 : _b2.call(_a2, err);\n                } catch (errorHandlerErr) {\n                  err = errorHandlerErr;\n                  handleRedirectAndNotFound(this.getMatch(matchId), err);\n                }\n                updateMatch(matchId, prev => {\n                  var _a3;\n                  (_a3 = prev.beforeLoadPromise) == null ? void 0 : _a3.resolve();\n                  return {\n                    ...prev,\n                    error: err,\n                    status: \"error\",\n                    isFetching: false,\n                    updatedAt: Date.now(),\n                    abortController: new AbortController(),\n                    beforeLoadPromise: void 0\n                  };\n                });\n              };\n              for (const [index, {\n                id: matchId,\n                routeId\n              }] of matches.entries()) {\n                const existingMatch = this.getMatch(matchId);\n                const parentMatchId = (_a = matches[index - 1]) == null ? void 0 : _a.id;\n                if (\n                // If we are in the middle of a load, either of these will be present\n                // (not to be confused with `loadPromise`, which is always defined)\n                existingMatch.beforeLoadPromise || existingMatch.loaderPromise) {\n                  await existingMatch.beforeLoadPromise;\n                } else {\n                  try {\n                    updateMatch(matchId, prev => ({\n                      ...prev,\n                      loadPromise: createControlledPromise(() => {\n                        var _a2;\n                        (_a2 = prev.loadPromise) == null ? void 0 : _a2.resolve();\n                      }),\n                      beforeLoadPromise: createControlledPromise()\n                    }));\n                    const route = this.looseRoutesById[routeId];\n                    const abortController = new AbortController();\n                    const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;\n                    const shouldPending = !!(onReady && !this.isServer && !preload && (route.options.loader || route.options.beforeLoad) && typeof pendingMs === \"number\" && pendingMs !== Infinity && (route.options.pendingComponent ?? this.options.defaultPendingComponent));\n                    let pendingTimeout;\n                    if (shouldPending) {\n                      pendingTimeout = setTimeout(() => {\n                        try {\n                          triggerOnReady();\n                        } catch {}\n                      }, pendingMs);\n                    }\n                    const {\n                      paramsError,\n                      searchError\n                    } = this.getMatch(matchId);\n                    if (paramsError) {\n                      handleSerialError(index, paramsError, \"PARSE_PARAMS\");\n                    }\n                    if (searchError) {\n                      handleSerialError(index, searchError, \"VALIDATE_SEARCH\");\n                    }\n                    const getParentMatchContext = () => parentMatchId ? this.getMatch(parentMatchId).context : this.options.context ?? {};\n                    updateMatch(matchId, prev => ({\n                      ...prev,\n                      isFetching: \"beforeLoad\",\n                      fetchCount: prev.fetchCount + 1,\n                      abortController,\n                      pendingTimeout,\n                      context: {\n                        ...getParentMatchContext(),\n                        ...prev.__routeContext,\n                        ...prev.__beforeLoadContext\n                      }\n                    }));\n                    const {\n                      search,\n                      params,\n                      context,\n                      cause\n                    } = this.getMatch(matchId);\n                    const beforeLoadFnContext = {\n                      search,\n                      abortController,\n                      params,\n                      preload: !!preload,\n                      context,\n                      location,\n                      navigate: opts => this.navigate({\n                        ...opts,\n                        _fromLocation: location\n                      }),\n                      buildLocation: this.buildLocation,\n                      cause: preload ? \"preload\" : cause\n                    };\n                    let beforeLoadContext = (await ((_c = (_b = route.options).beforeLoad) == null ? void 0 : _c.call(_b, beforeLoadFnContext))) ?? {};\n                    if (this.serializeLoaderData) {\n                      beforeLoadContext = this.serializeLoaderData(\"__beforeLoadContext\", beforeLoadContext, {\n                        router: this,\n                        match: this.getMatch(matchId)\n                      });\n                    }\n                    if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {\n                      handleSerialError(index, beforeLoadContext, \"BEFORE_LOAD\");\n                    }\n                    updateMatch(matchId, prev => {\n                      return {\n                        ...prev,\n                        __beforeLoadContext: beforeLoadContext,\n                        context: {\n                          ...getParentMatchContext(),\n                          ...prev.__routeContext,\n                          ...beforeLoadContext\n                        },\n                        abortController\n                      };\n                    });\n                  } catch (err) {\n                    handleSerialError(index, err, \"BEFORE_LOAD\");\n                  }\n                  updateMatch(matchId, prev => {\n                    var _a2;\n                    (_a2 = prev.beforeLoadPromise) == null ? void 0 : _a2.resolve();\n                    return {\n                      ...prev,\n                      beforeLoadPromise: void 0,\n                      isFetching: false\n                    };\n                  });\n                }\n              }\n              const validResolvedMatches = matches.slice(0, firstBadMatchIndex);\n              const matchPromises = [];\n              validResolvedMatches.forEach((_ref6, index) => {\n                let {\n                  id: matchId,\n                  routeId\n                } = _ref6;\n                matchPromises.push((async () => {\n                  const {\n                    loaderPromise: prevLoaderPromise\n                  } = this.getMatch(matchId);\n                  if (prevLoaderPromise) {\n                    await prevLoaderPromise;\n                  } else {\n                    const parentMatchPromise = matchPromises[index - 1];\n                    const route = this.looseRoutesById[routeId];\n                    const getLoaderContext = () => {\n                      const {\n                        params,\n                        loaderDeps,\n                        abortController,\n                        context,\n                        cause\n                      } = this.getMatch(matchId);\n                      return {\n                        params,\n                        deps: loaderDeps,\n                        preload: !!preload,\n                        parentMatchPromise,\n                        abortController,\n                        context,\n                        location,\n                        navigate: opts => this.navigate({\n                          ...opts,\n                          _fromLocation: location\n                        }),\n                        cause: preload ? \"preload\" : cause,\n                        route\n                      };\n                    };\n                    const age = Date.now() - this.getMatch(matchId).updatedAt;\n                    const staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0;\n                    const shouldReloadOption = route.options.shouldReload;\n                    const shouldReload = typeof shouldReloadOption === \"function\" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;\n                    updateMatch(matchId, prev => ({\n                      ...prev,\n                      loaderPromise: createControlledPromise(),\n                      preload: !!preload && !this.state.matches.find(d => d.id === matchId)\n                    }));\n                    const runLoader = async () => {\n                      var _a2, _b2, _c2, _d, _e, _f, _g, _h;\n                      try {\n                        const potentialPendingMinPromise = async () => {\n                          const latestMatch = this.getMatch(matchId);\n                          if (latestMatch.minPendingPromise) {\n                            await latestMatch.minPendingPromise;\n                          }\n                        };\n                        try {\n                          route._lazyPromise = route._lazyPromise || (route.lazyFn ? route.lazyFn().then(lazyRoute => {\n                            Object.assign(route.options, lazyRoute.options);\n                          }) : Promise.resolve());\n                          const componentsPromise = this.getMatch(matchId).componentsPromise || route._lazyPromise.then(() => Promise.all(componentTypes.map(async type => {\n                            const component = route.options[type];\n                            if (component == null ? void 0 : component.preload) {\n                              await component.preload();\n                            }\n                          })));\n                          updateMatch(matchId, prev => ({\n                            ...prev,\n                            isFetching: \"loader\",\n                            componentsPromise\n                          }));\n                          await route._lazyPromise;\n                          let loaderData = await ((_b2 = (_a2 = route.options).loader) == null ? void 0 : _b2.call(_a2, getLoaderContext()));\n                          if (this.serializeLoaderData) {\n                            loaderData = this.serializeLoaderData(\"loaderData\", loaderData, {\n                              router: this,\n                              match: this.getMatch(matchId)\n                            });\n                          }\n                          handleRedirectAndNotFound(this.getMatch(matchId), loaderData);\n                          await potentialPendingMinPromise();\n                          const meta = (_d = (_c2 = route.options).meta) == null ? void 0 : _d.call(_c2, {\n                            matches,\n                            match: this.getMatch(matchId),\n                            params: this.getMatch(matchId).params,\n                            loaderData\n                          });\n                          const headers = (_f = (_e = route.options).headers) == null ? void 0 : _f.call(_e, {\n                            loaderData\n                          });\n                          updateMatch(matchId, prev => ({\n                            ...prev,\n                            error: void 0,\n                            status: \"success\",\n                            isFetching: false,\n                            updatedAt: Date.now(),\n                            loaderData,\n                            meta,\n                            headers\n                          }));\n                        } catch (e) {\n                          let error = e;\n                          await potentialPendingMinPromise();\n                          handleRedirectAndNotFound(this.getMatch(matchId), e);\n                          try {\n                            (_h = (_g = route.options).onError) == null ? void 0 : _h.call(_g, e);\n                          } catch (onErrorError) {\n                            error = onErrorError;\n                            handleRedirectAndNotFound(this.getMatch(matchId), onErrorError);\n                          }\n                          updateMatch(matchId, prev => ({\n                            ...prev,\n                            error,\n                            status: \"error\",\n                            isFetching: false\n                          }));\n                        }\n                        await this.getMatch(matchId).componentsPromise;\n                      } catch (err) {\n                        handleRedirectAndNotFound(this.getMatch(matchId), err);\n                      }\n                    };\n                    const {\n                      status,\n                      invalid\n                    } = this.getMatch(matchId);\n                    if (preload && route.options.preload === false) {} else if (status === \"success\" && (invalid || (shouldReload ?? age > staleAge))) {\n                      ;\n                      (async () => {\n                        try {\n                          await runLoader();\n                        } catch (err) {}\n                      })();\n                    } else if (status !== \"success\") {\n                      await runLoader();\n                    }\n                    const {\n                      loaderPromise,\n                      loadPromise\n                    } = this.getMatch(matchId);\n                    loaderPromise == null ? void 0 : loaderPromise.resolve();\n                    loadPromise == null ? void 0 : loadPromise.resolve();\n                  }\n                  updateMatch(matchId, prev => ({\n                    ...prev,\n                    isFetching: false,\n                    loaderPromise: void 0\n                  }));\n                })());\n              });\n              await Promise.all(matchPromises);\n              resolveAll();\n            } catch (err) {\n              rejectAll(err);\n            }\n          })();\n        });\n        await triggerOnReady();\n      } catch (err) {\n        if (isRedirect(err) || isNotFound(err)) {\n          if (isNotFound(err) && !preload) {\n            await triggerOnReady();\n          }\n          throw err;\n        }\n      }\n      return matches;\n    };\n    this.invalidate = () => {\n      const invalidate = d => ({\n        ...d,\n        invalid: true,\n        ...(d.status === \"error\" ? {\n          status: \"pending\",\n          error: void 0\n        } : {})\n      });\n      this.__store.setState(s => {\n        var _a;\n        return {\n          ...s,\n          matches: s.matches.map(invalidate),\n          cachedMatches: s.cachedMatches.map(invalidate),\n          pendingMatches: (_a = s.pendingMatches) == null ? void 0 : _a.map(invalidate)\n        };\n      });\n      return this.load();\n    };\n    this.resolveRedirect = err => {\n      const redirect = err;\n      if (!redirect.href) {\n        redirect.href = this.buildLocation(redirect).href;\n      }\n      return redirect;\n    };\n    this.cleanCache = () => {\n      this.__store.setState(s => {\n        return {\n          ...s,\n          cachedMatches: s.cachedMatches.filter(d => {\n            const route = this.looseRoutesById[d.routeId];\n            if (!route.options.loader) {\n              return false;\n            }\n            const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;\n            return d.status !== \"error\" && Date.now() - d.updatedAt < gcTime;\n          })\n        };\n      });\n    };\n    this.preloadRoute = async opts => {\n      const next = this.buildLocation(opts);\n      let matches = this.matchRoutes(next, {\n        throwOnError: true,\n        preload: true\n      });\n      const loadedMatchIds = Object.fromEntries([...this.state.matches, ...(this.state.pendingMatches ?? []), ...this.state.cachedMatches].map(d => [d.id, true]));\n      this.__store.batch(() => {\n        matches.forEach(match => {\n          if (!loadedMatchIds[match.id]) {\n            this.__store.setState(s => ({\n              ...s,\n              cachedMatches: [...s.cachedMatches, match]\n            }));\n          }\n        });\n      });\n      const activeMatchIds = new Set([...this.state.matches, ...(this.state.pendingMatches ?? [])].map(d => d.id));\n      try {\n        matches = await this.loadMatches({\n          matches,\n          location: next,\n          preload: true,\n          updateMatch: (id, updater) => {\n            if (activeMatchIds.has(id)) {\n              matches = matches.map(d => d.id === id ? updater(d) : d);\n            } else {\n              this.updateMatch(id, updater);\n            }\n          }\n        });\n        return matches;\n      } catch (err) {\n        if (isRedirect(err)) {\n          return await this.preloadRoute({\n            ...err,\n            _fromLocation: next\n          });\n        }\n        console.error(err);\n        return void 0;\n      }\n    };\n    this.matchRoute = (location, opts) => {\n      const matchLocation = {\n        ...location,\n        to: location.to ? this.resolvePathWithBase(location.from || \"\", location.to) : void 0,\n        params: location.params || {},\n        leaveParams: true\n      };\n      const next = this.buildLocation(matchLocation);\n      if ((opts == null ? void 0 : opts.pending) && this.state.status !== \"pending\") {\n        return false;\n      }\n      const pending = (opts == null ? void 0 : opts.pending) === void 0 ? !this.state.isLoading : opts.pending;\n      const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation;\n      const match = matchPathname(this.basepath, baseLocation.pathname, {\n        ...opts,\n        to: next.pathname\n      });\n      if (!match) {\n        return false;\n      }\n      if (location.params) {\n        if (!deepEqual(match, location.params, true)) {\n          return false;\n        }\n      }\n      if (match && ((opts == null ? void 0 : opts.includeSearch) ?? true)) {\n        return deepEqual(baseLocation.search, next.search, true) ? match : false;\n      }\n      return match;\n    };\n    this.dehydrate = () => {\n      var _a;\n      const pickError = ((_a = this.options.errorSerializer) == null ? void 0 : _a.serialize) ?? defaultSerializeError;\n      return {\n        state: {\n          dehydratedMatches: this.state.matches.map(d => {\n            return {\n              ...pick(d, [\"id\", \"status\", \"updatedAt\"]),\n              // If an error occurs server-side during SSRing,\n              // send a small subset of the error to the client\n              error: d.error ? {\n                data: pickError(d.error),\n                __isServerError: true\n              } : void 0\n              // NOTE: We don't send the loader data here, because\n              // there is a potential that it needs to be streamed.\n              // Instead, we render it next to the route match in the HTML\n              // which gives us the potential to stream it via suspense.\n            };\n          })\n        },\n        manifest: this.manifest\n      };\n    };\n    this.hydrate = () => {\n      var _a, _b, _c;\n      let ctx;\n      if (typeof document !== \"undefined\") {\n        ctx = this.options.transformer.parse((_a = window.__TSR__) == null ? void 0 : _a.dehydrated);\n      }\n      invariant(ctx, \"Expected to find a dehydrated data on window.__TSR__.dehydrated... but we did not. Please file an issue!\");\n      this.dehydratedData = ctx.payload;\n      (_c = (_b = this.options).hydrate) == null ? void 0 : _c.call(_b, ctx.payload);\n      const dehydratedState = ctx.router.state;\n      const matches = this.matchRoutes(this.state.location).map(match => {\n        const dehydratedMatch = dehydratedState.dehydratedMatches.find(d => d.id === match.id);\n        invariant(dehydratedMatch, `Could not find a client-side match for dehydrated match with id: ${match.id}!`);\n        return {\n          ...match,\n          ...dehydratedMatch\n        };\n      });\n      this.__store.setState(s => {\n        return {\n          ...s,\n          matches\n        };\n      });\n      this.manifest = ctx.router.manifest;\n    };\n    this.injectedHtml = [];\n    this.injectHtml = html => {\n      const cb = () => {\n        this.injectedHtml = this.injectedHtml.filter(d => d !== cb);\n        return html;\n      };\n      this.injectedHtml.push(cb);\n    };\n    this.streamedKeys = /* @__PURE__ */new Set();\n    this.getStreamedValue = key => {\n      var _a;\n      if (this.isServer) {\n        return void 0;\n      }\n      const streamedValue = (_a = window.__TSR__) == null ? void 0 : _a.streamedValues[key];\n      if (!streamedValue) {\n        return;\n      }\n      if (!streamedValue.parsed) {\n        streamedValue.parsed = this.options.transformer.parse(streamedValue.value);\n      }\n      return streamedValue.parsed;\n    };\n    this.streamValue = (key, value) => {\n      var _a;\n      warning(!this.streamedKeys.has(key), \"Key has already been streamed: \" + key);\n      this.streamedKeys.add(key);\n      const children = `__TSR__.streamedValues['${key}'] = { value: ${(_a = this.serializer) == null ? void 0 : _a.call(this, this.options.transformer.stringify(value))}}`;\n      this.injectHtml(`<script class='tsr-once'>${children}${process.env.NODE_ENV === \"development\" ? `; console.info(\\`Injected From Server:\n        ${children}\\`)` : \"\"}; __TSR__.cleanScripts()<\\/script>`);\n    };\n    this._handleNotFound = function (matches, err) {\n      let {\n        updateMatch = _this.updateMatch\n      } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      const matchesByRouteId = Object.fromEntries(matches.map(match2 => [match2.routeId, match2]));\n      let routeCursor = (err.global ? _this.looseRoutesById[rootRouteId] : _this.looseRoutesById[err.routeId]) || _this.looseRoutesById[rootRouteId];\n      while (!routeCursor.options.notFoundComponent && !_this.options.defaultNotFoundComponent && routeCursor.id !== rootRouteId) {\n        routeCursor = routeCursor.parentRoute;\n        invariant(routeCursor, \"Found invalid route tree while trying to find not-found handler.\");\n      }\n      const match = matchesByRouteId[routeCursor.id];\n      invariant(match, \"Could not find match for route: \" + routeCursor.id);\n      updateMatch(match.id, prev => ({\n        ...prev,\n        status: \"notFound\",\n        error: err,\n        isFetching: false\n      }));\n      if (err.routerCode === \"BEFORE_LOAD\" && routeCursor.parentRoute) {\n        err.routeId = routeCursor.parentRoute.id;\n        _this._handleNotFound(matches, err, {\n          updateMatch\n        });\n      }\n    };\n    this.hasNotFoundMatch = () => {\n      return this.__store.state.matches.some(d => d.status === \"notFound\" || d.globalNotFound);\n    };\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1e3,\n      defaultPendingMinMs: 500,\n      context: void 0,\n      ...options,\n      notFoundMode: options.notFoundMode ?? \"fuzzy\",\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n      transformer: options.transformer ?? defaultTransformer\n    });\n    if (typeof document !== \"undefined\") {\n      window.__TSR__ROUTER__ = this;\n    }\n  }\n  get state() {\n    return this.__store.state;\n  }\n  get looseRoutesById() {\n    return this.routesById;\n  }\n  matchRoutes(pathnameOrNext, locationSearchOrOpts, opts) {\n    if (typeof pathnameOrNext === \"string\") {\n      return this.matchRoutesInternal({\n        pathname: pathnameOrNext,\n        search: locationSearchOrOpts\n      }, opts);\n    } else {\n      return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts);\n    }\n  }\n  matchRoutesInternal(next, opts) {\n    let routeParams = {};\n    const foundRoute = this.flatRoutes.find(route => {\n      const matchedParams = matchPathname(this.basepath, trimPathRight(next.pathname), {\n        to: route.fullPath,\n        caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,\n        fuzzy: true\n      });\n      if (matchedParams) {\n        routeParams = matchedParams;\n        return true;\n      }\n      return false;\n    });\n    let routeCursor = foundRoute || this.routesById[rootRouteId];\n    const matchedRoutes = [routeCursor];\n    let isGlobalNotFound = false;\n    if (\n    // If we found a route, and it's not an index route and we have left over path\n    foundRoute ? foundRoute.path !== \"/\" && routeParams[\"**\"] :\n    // Or if we didn't find a route and we have left over path\n    trimPathRight(next.pathname)) {\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute);\n      } else {\n        isGlobalNotFound = true;\n      }\n    }\n    while (routeCursor.parentRoute) {\n      routeCursor = routeCursor.parentRoute;\n      matchedRoutes.unshift(routeCursor);\n    }\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return void 0;\n      }\n      if (this.options.notFoundMode !== \"root\") {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i];\n          if (route.children) {\n            return route.id;\n          }\n        }\n      }\n      return rootRouteId;\n    })();\n    const parseErrors = matchedRoutes.map(route => {\n      var _a;\n      let parsedParamsError;\n      const parseParams = ((_a = route.options.params) == null ? void 0 : _a.parse) ?? route.options.parseParams;\n      if (parseParams) {\n        try {\n          const parsedParams = parseParams(routeParams);\n          Object.assign(routeParams, parsedParams);\n        } catch (err) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err\n          });\n          if (opts == null ? void 0 : opts.throwOnError) {\n            throw parsedParamsError;\n          }\n          return parsedParamsError;\n        }\n      }\n      return;\n    });\n    const matches = [];\n    matchedRoutes.forEach((route, index) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n      const parentMatch = matches[index - 1];\n      const [preMatchSearch, searchError] = (() => {\n        const parentSearch = (parentMatch == null ? void 0 : parentMatch.search) ?? next.search;\n        try {\n          const validator = typeof route.options.validateSearch === \"object\" ? route.options.validateSearch.parse : route.options.validateSearch;\n          const search = (validator == null ? void 0 : validator(parentSearch)) ?? {};\n          return [{\n            ...parentSearch,\n            ...search\n          }, void 0];\n        } catch (err) {\n          const searchParamError = new SearchParamError(err.message, {\n            cause: err\n          });\n          if (opts == null ? void 0 : opts.throwOnError) {\n            throw searchParamError;\n          }\n          return [parentSearch, searchParamError];\n        }\n      })();\n      const loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {\n        search: preMatchSearch\n      })) ?? \"\";\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : \"\";\n      const interpolatedPath = interpolatePath({\n        path: route.fullPath,\n        params: routeParams\n      });\n      const matchId = interpolatePath({\n        path: route.id,\n        params: routeParams,\n        leaveWildcards: true\n      }) + loaderDepsHash;\n      const existingMatch = this.getMatch(matchId);\n      const cause = this.state.matches.find(d => d.id === matchId) ? \"stay\" : \"enter\";\n      let match;\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: routeParams\n        };\n      } else {\n        const status = route.options.loader || route.options.beforeLoad || route.lazyFn ? \"pending\" : \"success\";\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([this.basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          search: {},\n          searchError: void 0,\n          status,\n          isFetching: false,\n          error: void 0,\n          paramsError: parseErrors[index],\n          __routeContext: {},\n          __beforeLoadContext: {},\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps,\n          invalid: false,\n          preload: false,\n          links: (_d = (_c = route.options).links) == null ? void 0 : _d.call(_c),\n          scripts: (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e),\n          staticData: route.options.staticData || {},\n          loadPromise: createControlledPromise(),\n          fullPath: route.fullPath\n        };\n      }\n      if (match.status === \"success\") {\n        match.meta = (_h = (_g = route.options).meta) == null ? void 0 : _h.call(_g, {\n          matches,\n          match,\n          params: match.params,\n          loaderData: match.loaderData\n        });\n        match.headers = (_j = (_i = route.options).headers) == null ? void 0 : _j.call(_i, {\n          loaderData: match.loaderData\n        });\n      }\n      if (!(opts == null ? void 0 : opts.preload)) {\n        match.globalNotFound = globalNotFoundRouteId === route.id;\n      }\n      match.search = replaceEqualDeep(match.search, preMatchSearch);\n      match.searchError = searchError;\n      const parentMatchId = parentMatch == null ? void 0 : parentMatch.id;\n      const parentContext = !parentMatchId ? this.options.context ?? {} : parentMatch.context ?? this.options.context ?? {};\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext\n      };\n      const contextFnContext = {\n        search: match.search,\n        params: match.params,\n        context: match.context,\n        location: next,\n        navigate: opts2 => this.navigate({\n          ...opts2,\n          _fromLocation: next\n        }),\n        buildLocation: this.buildLocation,\n        cause: match.cause,\n        abortController: match.abortController,\n        preload: !!match.preload\n      };\n      match.__routeContext = ((_l = (_k = route.options).context) == null ? void 0 : _l.call(_k, contextFnContext)) ?? {};\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext\n      };\n      matches.push(match);\n    });\n    return matches;\n  }\n}\nfunction lazyFn(fn, key) {\n  return async function () {\n    const imported = await fn();\n    return imported[key || \"default\"](...arguments);\n  };\n}\nclass SearchParamError extends Error {}\nclass PathParamError extends Error {}\nfunction getInitialRouterState(location) {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: \"idle\",\n    resolvedLocation: {\n      ...location\n    },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200\n  };\n}\nfunction defaultSerializeError(err) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message\n    };\n    if (process.env.NODE_ENV === \"development\") {\n      obj.stack = err.stack;\n    }\n    return obj;\n  }\n  return {\n    data: err\n  };\n}\nexport { PathParamError, Router, SearchParamError, componentTypes, createRouter, defaultSerializeError, getInitialRouterState, lazyFn };","map":{"version":3,"names":["componentTypes","createRouter","options","Router","constructor","_this","tempLocationKey","Math","round","random","resetNextScroll","shouldViewTransition","subscribers","Set","startReactTransition","fn","update","newOptions","notFoundRoute","console","warn","previousOptions","isServer","document","basepath","trimPath","history","createMemoryHistory","initialEntries","createBrowserHistory","latestLocation","parseLocation","routeTree","buildRouteTree","__store","Store","getInitialRouterState","onUpdate","state","cachedMatches","filter","d","includes","status","routesById","routesByPath","init","originalIndex","id","recurseRoutes","childRoutes","forEach","childRoute","i","existingRoute","invariant","String","isRoot","path","trimmedFullPath","trimPathRight","fullPath","endsWith","children","length","scoredRoutes","routes","Object","values","trimmed","trimPathLeft","parsed","parsePathname","_a","value","shift","scores","map","segment","type","push","child","index","flatRoutes","sort","a","b","minLength","min","rank","subscribe","eventType","listener","add","delete","emit","routerEvent","previousLocation","parse","_ref","pathname","search","hash","parsedSearch","parseSearch","searchStr","stringifySearch","replaceEqualDeep","split","reverse","href","location","__tempLocation","__tempKey","parsedTempLocation","key","maskedLocation","resolvePathWithBase","from","resolvedPath","resolvePath","base","to","cleanPath","trailingSlash","cancelMatch","match","getMatch","abortController","abort","clearTimeout","pendingTimeout","cancelMatches","pendingMatches","buildLocation","opts","build","dest","arguments","undefined","matches","fromMatches","_fromLocation","matchRoutes","fromSearch","fromMatch","find","matchPathname","caseSensitive","fuzzy","fromPath","last","stayingMatches","e","routeId","fromRouteByFromPathRouteId","_b","prevParams","_c","params","nextParams","functionalUpdate","keys","route","looseRoutesById","_a2","stringify","stringifyParams","Boolean","interpolatePath","leaveWildcards","leaveParams","preSearchFilters","flat","postSearchFilters","preFilteredSearch","reduce","prev","next","destSearch","postFilteredSearch","hashStr","nextState","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","maskProps","pick","nextMatches","maskedMatches","maskedFinal","final","mask","commitLocation","_ref2","viewTransition","ignoreBlocker","isSameState","isEqual","deepEqual","isSameUrl","previousCommitPromise","commitLocationPromise","createControlledPromise","resolve","load","nextHistory","replace","resetScroll","size","buildAndCommitLocation","rest","parseHref","navigate","_ref3","__isRedirect","toString","isExternal","URL","setState","s","loadedAt","Date","now","redirect","notFound","loadPromise","Promise","prevLocation","resolvedLocation","pathDidChange","batch","isLoading","fromLocation","toLocation","pathChanged","loadMatches","onReady","startViewTransition","exitingMatches","enteringMatches","previousMatches","newMatches","cleanCache","_ref4","hook","call","err","isResolvedRedirect","isNotFound","statusCode","some","latestLoadPromise","defaultViewTransition","updateMatch","updater","updated","isPending","isMatched","matchesKey","matchId","_ref5","preload","firstBadMatchIndex","rendered","triggerOnReady","handleRedirectAndNotFound","isRedirect","isFetching","error","beforeLoadPromise","loaderPromise","resolveRedirect","_handleNotFound","resolveAll","rejectAll","handleSerialError","routerCode","_b2","onError","errorHandlerErr","_a3","updatedAt","AbortController","entries","existingMatch","parentMatchId","pendingMs","defaultPendingMs","shouldPending","loader","beforeLoad","Infinity","pendingComponent","defaultPendingComponent","setTimeout","paramsError","searchError","getParentMatchContext","context","fetchCount","__routeContext","__beforeLoadContext","cause","beforeLoadFnContext","beforeLoadContext","serializeLoaderData","router","validResolvedMatches","slice","matchPromises","_ref6","prevLoaderPromise","parentMatchPromise","getLoaderContext","loaderDeps","deps","age","staleAge","preloadStaleTime","defaultPreloadStaleTime","staleTime","defaultStaleTime","shouldReloadOption","shouldReload","runLoader","potentialPendingMinPromise","latestMatch","minPendingPromise","_lazyPromise","lazyFn","then","lazyRoute","assign","componentsPromise","all","component","loaderData","meta","_d","_c2","headers","_f","_e","_h","_g","onErrorError","invalid","invalidate","gcTime","preloadGcTime","defaultPreloadGcTime","defaultGcTime","preloadRoute","throwOnError","loadedMatchIds","fromEntries","activeMatchIds","has","matchRoute","matchLocation","pending","baseLocation","includeSearch","dehydrate","pickError","errorSerializer","serialize","defaultSerializeError","dehydratedMatches","data","__isServerError","manifest","hydrate","ctx","transformer","window","__TSR__","dehydrated","dehydratedData","payload","dehydratedState","dehydratedMatch","injectedHtml","injectHtml","html","cb","streamedKeys","getStreamedValue","streamedValue","streamedValues","streamValue","warning","serializer","process","env","NODE_ENV","matchesByRouteId","match2","routeCursor","global","rootRouteId","notFoundComponent","defaultNotFoundComponent","parentRoute","hasNotFoundMatch","globalNotFound","defaultPreloadDelay","defaultPendingMinMs","notFoundMode","defaultStringifySearch","defaultParseSearch","defaultTransformer","__TSR__ROUTER__","pathnameOrNext","locationSearchOrOpts","matchRoutesInternal","routeParams","foundRoute","matchedParams","matchedRoutes","isGlobalNotFound","unshift","globalNotFoundRouteId","parseErrors","parsedParamsError","parseParams","parsedParams","PathParamError","message","parentMatch","preMatchSearch","parentSearch","validator","validateSearch","searchParamError","SearchParamError","loaderDepsHash","JSON","interpolatedPath","joinPaths","links","scripts","staticData","_j","_i","parentContext","contextFnContext","opts2","_l","_k","imported","Error","isTransitioning","obj","name","stack"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react-test/carroway-react-test/node_modules/@tanstack/react-router/src/router.ts"],"sourcesContent":["import {\n  createBrowserHistory,\n  createMemoryHistory,\n  parseHref,\n} from '@tanstack/history'\nimport { Store } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { rootRouteId } from './root'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  createControlledPromise,\n  deepEqual,\n  functionalUpdate,\n  last,\n  pick,\n  replaceEqualDeep,\n} from './utils'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport { isRedirect, isResolvedRedirect } from './redirects'\nimport { isNotFound } from './not-found'\nimport { defaultTransformer } from './transformer'\nimport type * as React from 'react'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type { NoInfer } from '@tanstack/react-store'\nimport type { Manifest } from './manifest'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  AnySearchSchema,\n  BeforeLoadContextOptions,\n  ErrorRouteComponent,\n  LoaderFnContext,\n  NotFoundRouteComponent,\n  RootRoute,\n  RouteComponent,\n  RouteContextOptions,\n  RouteMask,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  ControlledPromise,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MatchRouteOptions,\n} from './Matches'\nimport type { ParsedLocation } from './location'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type { AnyRedirect, ResolvedRedirect } from './redirects'\nimport type { NotFoundError } from './not-found'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { RouterTransformer } from './transformer'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR__?: {\n      matches: Array<{\n        __beforeLoadContext?: string\n        loaderData?: string\n        extracted?: Array<ExtractedEntry>\n      }>\n      streamedValues: Record<\n        string,\n        {\n          value: any\n          parsed: any\n        }\n      >\n      cleanScripts: () => void\n      dehydrated?: any\n    }\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any, any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any, any, any>\n\nexport type AnyRouterWithContext<TContext> = Router<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any\n>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree extends RootRoute<\n    any,\n    infer TRouterContext extends AnyContext,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n    ? TRouterContext\n    : AnyContext\n\nexport type ExtractedEntry = {\n  dataType: '__beforeLoadContext' | 'loaderData'\n  type: 'promise' | 'stream'\n  path: Array<string>\n  value: any\n  id: number\n  streamState?: StreamState\n  matchIndex: number\n}\n\nexport type StreamState = {\n  promises: Array<ControlledPromise<string | null>>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type TrailingSlashOption = 'always' | 'never' | 'preserve'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: RouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `component` a route should use if no component is provided.\n   *\n   * @default Outlet\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultcomponent-property)\n   */\n  defaultComponent?: RouteComponent\n  /**\n   * The default `errorComponent` a route should use if no error component is provided.\n   *\n   * @default ErrorComponent\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulterrorcomponent-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)\n   */\n  defaultErrorComponent?: ErrorRouteComponent\n  /**\n   * The default `pendingComponent` a route should use if no pending component is provided.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingcomponent-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#showing-a-pending-component)\n   */\n  defaultPendingComponent?: RouteComponent\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * The default `onCatch` handler for errors caught by the Router ErrorBoundary\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultoncatch-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionsoncatch)\n   */\n  defaultOnCatch?: (error: Error, errorInfo: React.ErrorInfo) => void\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-trees#case-sensitivity)\n   */\n  caseSensitive?: boolean\n  /**\n   * __Required*__\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   *\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => TDehydrated\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => void\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n  /**\n   * A component that will be used to wrap the entire router.\n   *\n   * This is useful for providing a context to the entire router.\n   *\n   * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#wrap-property)\n   */\n  Wrap?: (props: { children: any }) => React.JSX.Element\n  /**\n   * A component that will be used to wrap the inner contents of the router.\n   *\n   * This is useful for providing a context to the inner contents of the router where you also need access to the router context and hooks.\n   *\n   * Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#innerwrap-property)\n   */\n  InnerWrap?: (props: { children: any }) => React.JSX.Element\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * The default `notFoundComponent` a route should use if no notFound component is provided.\n   *\n   * @default NotFound\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultnotfoundcomponent-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#default-router-wide-not-found-handling)\n   */\n  defaultNotFoundComponent?: NotFoundRouteComponent\n  /**\n   * The transformer that will be used when sending data between the server and the client during SSR.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#transformer-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/ssr#data-transformers)\n   */\n  transformer?: RouterTransformer\n  /**\n   * The serializer object that will be used to determine how errors are serialized and deserialized between the server and the client.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#errorserializer-property)\n   */\n  errorSerializer?: RouterErrorSerializer<TSerializedError>\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver property)\n   */\n  isServer?: boolean\n}\n\nexport interface RouterErrorSerializer<TSerializedError> {\n  serialize: (err: unknown) => TSerializedError\n  deserialize: (err: TSerializedError) => unknown\n}\n\nexport interface RouterState<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteMatch = MakeRouteMatch<TRouteTree>,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: ResolvedRedirect\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  fromSearch?: unknown\n  _fromLocation?: ParsedLocation\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: Array<DehydratedRouteMatch>\n}\n\nexport type DehydratedRouteMatch = Pick<\n  MakeRouteMatch,\n  'id' | 'status' | 'updatedAt' | 'loaderData'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n  manifest?: Manifest\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any>,\n  TSerializedError extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >,\n  'context'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n  'notFoundComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport function createRouter<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n  TSerializedError extends Record<string, any> = Record<string, any>,\n>(\n  options: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >,\n) {\n  return new Router<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDehydrated,\n    TSerializedError\n  >(options)\n}\n\ntype MatchRoutesOpts = { preload?: boolean; throwOnError?: boolean }\n\nexport class Router<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n  in out TSerializedError extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  dehydratedData?: TDehydrated\n  viewTransitionPromise?: ControlledPromise<true>\n  manifest?: Manifest\n  AfterEachMatch?: (props: {\n    match: Pick<\n      AnyRouteMatch,\n      'id' | 'status' | 'error' | 'loadPromise' | 'minPendingPromise'\n    >\n    matchIndex: number\n  }) => any\n  serializeLoaderData?: (\n    type: '__beforeLoadContext' | 'loaderData',\n    loaderData: any,\n    ctx: {\n      router: AnyRouter\n      match: AnyRouteMatch\n    },\n  ) => any\n  serializer?: (data: any) => string\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    Omit<\n      RouterOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDehydrated,\n        TSerializedError\n      >,\n      'transformer'\n    > & {\n      transformer: RouterTransformer\n    },\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n  isServer!: boolean\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      notFoundMode: options.notFoundMode ?? 'fuzzy',\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n      transformer: options.transformer ?? defaultTransformer,\n    })\n\n    if (typeof document !== 'undefined') {\n      ;(window as any).__TSR__ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (\n    newOptions: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDehydrated,\n      TSerializedError\n    >,\n  ) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const previousOptions = this.options\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    if (\n      !this.basepath ||\n      (newOptions.basepath && newOptions.basepath !== previousOptions.basepath)\n    ) {\n      if (\n        newOptions.basepath === undefined ||\n        newOptions.basepath === '' ||\n        newOptions.basepath === '/'\n      ) {\n        this.basepath = '/'\n      } else {\n        this.basepath = `/${trimPath(newOptions.basepath)}`\n      }\n    }\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (this.isServer\n          ? createMemoryHistory({\n              initialEntries: [this.basepath || '/'],\n            })\n          : createBrowserHistory())\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: Array<AnyRoute>) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: Array<{\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: Array<number>\n    }> = []\n\n    const routes: Array<AnyRoute> = Object.values(this.routesById)\n\n    routes.forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((segment) => {\n        if (segment.value === '/') {\n          return 0.75\n        }\n\n        if (segment.type === 'param') {\n          return 0.5\n        }\n\n        if (segment.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value > b.parsed[i]!.value ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n\n      return {\n        pathname,\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${searchStr}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      basepath: this.basepath,\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  /** \n  @deprecated use the following signature instead\n  ```ts\n  matchRoutes (\n    next: ParsedLocation,\n    opts?: { preload?: boolean; throwOnError?: boolean },\n  ): Array<AnyRouteMatch>;\n  ```\n*/\n  public matchRoutes(\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n  public matchRoutes(\n    next: ParsedLocation,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n\n  public matchRoutes(\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?:\n      | AnySearchSchema\n      | { preload?: boolean; throwOnError?: boolean },\n    opts?: { preload?: boolean; throwOnError?: boolean },\n  ) {\n    if (typeof pathnameOrNext === 'string') {\n      return this.matchRoutesInternal(\n        {\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts,\n        } as ParsedLocation,\n        opts,\n      )\n    } else {\n      return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts)\n    }\n  }\n\n  private matchRoutesInternal(\n    next: ParsedLocation,\n    opts?: { preload?: boolean; throwOnError?: boolean },\n  ): Array<AnyRouteMatch> {\n    let routeParams: Record<string, string> = {}\n\n    const foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(next.pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)[rootRouteId]\n\n    const matchedRoutes: Array<AnyRoute> = [routeCursor]\n\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    while (routeCursor.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      matchedRoutes.unshift(routeCursor)\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      const parseParams =\n        route.options.params?.parse ?? route.options.parseParams\n\n      if (parseParams) {\n        try {\n          const parsedParams = parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: Array<AnyRouteMatch> = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? next.search\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          const search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchParamError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n      })\n\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n        }) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = this.getMatch(matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: routeParams,\n        }\n      } else {\n        const status =\n          route.options.loader || route.options.beforeLoad || route.lazyFn\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([this.basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          search: {} as any,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          __routeContext: {},\n          __beforeLoadContext: {},\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps,\n          invalid: false,\n          preload: false,\n          links: route.options.links?.(),\n          scripts: route.options.scripts?.(),\n          staticData: route.options.staticData || {},\n          loadPromise: createControlledPromise(),\n          fullPath: route.fullPath,\n        }\n      }\n\n      // If it's already a success, update the meta and headers\n      // These may get updated again if the match is refreshed\n      // due to being stale\n      if (match.status === 'success') {\n        match.meta = route.options.meta?.({\n          matches,\n          match,\n          params: match.params,\n          loaderData: match.loaderData,\n        })\n\n        match.headers = route.options.headers?.({\n          loaderData: match.loaderData,\n        })\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      const parentMatchId = parentMatch?.id\n\n      const parentContext = !parentMatchId\n        ? ((this.options.context as any) ?? {})\n        : (parentMatch.context ?? this.options.context ?? {})\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      // Update the match's context\n      const contextFnContext: RouteContextOptions<any, any, any, any> = {\n        search: match.search,\n        params: match.params,\n        context: match.context,\n        location: next,\n        navigate: (opts: any) =>\n          this.navigate({ ...opts, _fromLocation: next }),\n        buildLocation: this.buildLocation,\n        cause: match.cause,\n        abortController: match.abortController,\n        preload: !!match.preload,\n      }\n\n      // Get the route context\n      match.__routeContext = route.options.context?.(contextFnContext) ?? {}\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match.pendingTimeout)\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: Array<MakeRouteMatch<TRouteTree>>,\n    ): ParsedLocation => {\n      const fromMatches =\n        dest._fromLocation != null\n          ? this.matchRoutes({\n              ...dest._fromLocation,\n              search: dest.fromSearch || dest._fromLocation.search,\n            })\n          : this.state.matches\n\n      const fromMatch =\n        dest.from != null\n          ? fromMatches.find((d) =>\n              matchPathname(this.basepath, trimPathRight(d.pathname), {\n                to: dest.from,\n                caseSensitive: false,\n                fuzzy: false,\n              }),\n            )\n          : undefined\n\n      const fromPath = fromMatch?.pathname || this.latestLocation.pathname\n\n      invariant(\n        dest.from == null || fromMatch != null,\n        'Could not find match for from: ' + dest.from,\n      )\n\n      const fromSearch = last(fromMatches)?.search || this.latestLocation.search\n\n      const stayingMatches = matches?.filter((d) =>\n        fromMatches.find((e) => e.routeId === d.routeId),\n      )\n\n      const fromRouteByFromPathRouteId =\n        this.routesById[\n          stayingMatches?.find((d) => d.pathname === fromPath)?.routeId\n        ]\n\n      let pathname = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(\n            fromPath,\n            fromRouteByFromPathRouteId?.to ?? fromPath,\n          )\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : { ...prevParams, ...functionalUpdate(dest.params, prevParams) }\n\n      if (Object.keys(nextParams).length > 0) {\n        matches\n          ?.map((d) => {\n            const route = this.looseRoutesById[d.routeId]\n            return (\n              route?.options.params?.stringify ?? route!.options.stringifyParams\n            )\n          })\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams) }\n          })\n      }\n\n      pathname = interpolatePath({\n        path: pathname,\n        params: nextParams ?? {},\n        leaveWildcards: false,\n        leaveParams: opts.leaveParams,\n      })\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters.length\n        ? preSearchFilters.reduce((prev, next) => next(prev), fromSearch)\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) // Updater\n            : preSearchFilters.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? this.latestLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, this.latestLocation.hash)\n            : undefined\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? this.latestLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, this.latestLocation.state)\n            : {}\n\n      nextState = replaceEqualDeep(this.latestLocation.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          const { from, ...maskProps } = foundMask\n          maskedDest = {\n            ...pick(opts, ['from']),\n            ...maskProps,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  commitLocation = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }: ParsedLocation & CommitLocationOptions): Promise<void> => {\n    const isSameState = () => {\n      // `state.key` is ignored but may still be provided when navigating,\n      // temporarily add the previous key to the next state so it doesn't affect\n      // the comparison\n\n      next.state.key = this.latestLocation.state.key\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      delete next.state.key\n      return isEqual\n    }\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.href,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    viewTransition,\n    ignoreBlocker,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const href = (rest as any).href\n    if (href) {\n      const parsed = parseHref(href, {})\n      rest.to = parsed.pathname\n      rest.search = this.options.parseSearch(parsed.search)\n      rest.hash = parsed.hash\n    }\n\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      ignoreBlocker,\n    })\n  }\n\n  navigate: NavigateFn = ({ to, __isRedirect, ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with router.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      to,\n      // to: toString,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  load = async (): Promise<void> => {\n    this.latestLocation = this.parseLocation(this.latestLocation)\n\n    this.__store.setState((s) => ({\n      ...s,\n      loadedAt: Date.now(),\n    }))\n\n    let redirect: ResolvedRedirect | undefined\n    let notFound: NotFoundError | undefined\n\n    let loadPromise: Promise<void>\n\n    // eslint-disable-next-line prefer-const\n    loadPromise = new Promise<void>((resolve) => {\n      this.startReactTransition(async () => {\n        try {\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n          const pathDidChange = prevLocation.href !== next.href\n\n          // Cancel any pending matches\n          this.cancelMatches()\n\n          let pendingMatches!: Array<AnyRouteMatch>\n\n          this.__store.batch(() => {\n            // this call breaks a route context of destination route after a redirect\n            // we should be fine not eagerly calling this since we call it later\n            // this.cleanCache()\n\n            // Match the routes\n            pendingMatches = this.matchRoutes(next)\n\n            // Ingest the new matches\n            this.__store.setState((s) => ({\n              ...s,\n              status: 'pending',\n              isLoading: true,\n              location: next,\n              pendingMatches,\n              // If a cached moved to pendingMatches, remove it from cachedMatches\n              cachedMatches: s.cachedMatches.filter((d) => {\n                return !pendingMatches.find((e) => e.id === d.id)\n              }),\n            }))\n          })\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              fromLocation: prevLocation,\n              toLocation: next,\n              pathChanged: pathDidChange,\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            fromLocation: prevLocation,\n            toLocation: next,\n            pathChanged: pathDidChange,\n          })\n\n          await this.loadMatches({\n            matches: pendingMatches,\n            location: next,\n            // eslint-disable-next-line @typescript-eslint/require-await\n            onReady: async () => {\n              // eslint-disable-next-line @typescript-eslint/require-await\n              this.startViewTransition(async () => {\n                // this.viewTransitionPromise = createControlledPromise<true>()\n\n                // Commit the pending matches. If a previous match was\n                // removed, place it in the cachedMatches\n                let exitingMatches!: Array<AnyRouteMatch>\n                let enteringMatches!: Array<AnyRouteMatch>\n                let stayingMatches!: Array<AnyRouteMatch>\n\n                this.__store.batch(() => {\n                  this.__store.setState((s) => {\n                    const previousMatches = s.matches\n                    const newMatches = s.pendingMatches || s.matches\n\n                    exitingMatches = previousMatches.filter(\n                      (match) => !newMatches.find((d) => d.id === match.id),\n                    )\n                    enteringMatches = newMatches.filter(\n                      (match) =>\n                        !previousMatches.find((d) => d.id === match.id),\n                    )\n                    stayingMatches = previousMatches.filter((match) =>\n                      newMatches.find((d) => d.id === match.id),\n                    )\n\n                    return {\n                      ...s,\n                      isLoading: false,\n                      matches: newMatches,\n                      pendingMatches: undefined,\n                      cachedMatches: [\n                        ...s.cachedMatches,\n                        ...exitingMatches.filter((d) => d.status !== 'error'),\n                      ],\n                    }\n                  })\n                  this.cleanCache()\n                })\n\n                //\n                ;(\n                  [\n                    [exitingMatches, 'onLeave'],\n                    [enteringMatches, 'onEnter'],\n                    [stayingMatches, 'onStay'],\n                  ] as const\n                ).forEach(([matches, hook]) => {\n                  matches.forEach((match) => {\n                    this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isResolvedRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({ ...err, replace: true, __isRedirect: true })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.statusCode\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    ;(shouldViewTransition && typeof document !== 'undefined'\n      ? document\n      : undefined\n    )\n      // @ts-expect-error\n      ?.startViewTransition?.(fn) || fn()\n  }\n\n  updateMatch = (\n    id: string,\n    updater: (match: AnyRouteMatch) => AnyRouteMatch,\n  ) => {\n    let updated!: AnyRouteMatch\n    const isPending = this.state.pendingMatches?.find((d) => d.id === id)\n    const isMatched = this.state.matches.find((d) => d.id === id)\n\n    const matchesKey = isPending\n      ? 'pendingMatches'\n      : isMatched\n        ? 'matches'\n        : 'cachedMatches'\n\n    this.__store.setState((s) => ({\n      ...s,\n      [matchesKey]: s[matchesKey]?.map((d) =>\n        d.id === id ? (updated = updater(d)) : d,\n      ),\n    }))\n\n    return updated\n  }\n\n  getMatch = (matchId: string) => {\n    return [\n      ...this.state.cachedMatches,\n      ...(this.state.pendingMatches ?? []),\n      ...this.state.matches,\n    ].find((d) => d.id === matchId)\n  }\n\n  loadMatches = async ({\n    location,\n    matches,\n    preload,\n    onReady,\n    updateMatch = this.updateMatch,\n  }: {\n    location: ParsedLocation\n    matches: Array<AnyRouteMatch>\n    preload?: boolean\n    onReady?: () => Promise<void>\n    updateMatch?: (\n      id: string,\n      updater: (match: AnyRouteMatch) => AnyRouteMatch,\n    ) => void\n    getMatch?: (matchId: string) => AnyRouteMatch | undefined\n  }): Promise<Array<MakeRouteMatch>> => {\n    let firstBadMatchIndex: number | undefined\n    let rendered = false\n\n    const triggerOnReady = async () => {\n      if (!rendered) {\n        rendered = true\n        await onReady?.()\n      }\n    }\n\n    if (!this.isServer && !this.state.matches.length) {\n      triggerOnReady()\n    }\n\n    const handleRedirectAndNotFound = (match: AnyRouteMatch, err: any) => {\n      if (isResolvedRedirect(err)) throw err\n\n      if (isRedirect(err) || isNotFound(err)) {\n        updateMatch(match.id, (prev) => ({\n          ...prev,\n          status: isRedirect(err)\n            ? 'redirected'\n            : isNotFound(err)\n              ? 'notFound'\n              : 'error',\n          isFetching: false,\n          error: err,\n          beforeLoadPromise: undefined,\n          loaderPromise: undefined,\n        }))\n\n        if (!(err as any).routeId) {\n          ;(err as any).routeId = match.routeId\n        }\n\n        match.beforeLoadPromise?.resolve()\n        match.loaderPromise?.resolve()\n        match.loadPromise?.resolve()\n\n        if (isRedirect(err)) {\n          rendered = true\n          err = this.resolveRedirect({ ...err, _fromLocation: location })\n          throw err\n        } else if (isNotFound(err)) {\n          this._handleNotFound(matches, err, {\n            updateMatch,\n          })\n          throw err\n        }\n      }\n    }\n\n    try {\n      await new Promise<void>((resolveAll, rejectAll) => {\n        ;(async () => {\n          try {\n            const handleSerialError = (\n              index: number,\n              err: any,\n              routerCode: string,\n            ) => {\n              const { id: matchId, routeId } = matches[index]!\n              const route = this.looseRoutesById[routeId]!\n\n              // Much like suspense, we use a promise here to know if\n              // we've been outdated by a new loadMatches call and\n              // should abort the current async operation\n              if (err instanceof Promise) {\n                throw err\n              }\n\n              err.routerCode = routerCode\n              firstBadMatchIndex = firstBadMatchIndex ?? index\n              handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n\n              try {\n                route.options.onError?.(err)\n              } catch (errorHandlerErr) {\n                err = errorHandlerErr\n                handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n              }\n\n              updateMatch(matchId, (prev) => {\n                prev.beforeLoadPromise?.resolve()\n\n                return {\n                  ...prev,\n                  error: err,\n                  status: 'error',\n                  isFetching: false,\n                  updatedAt: Date.now(),\n                  abortController: new AbortController(),\n                  beforeLoadPromise: undefined,\n                }\n              })\n            }\n\n            for (const [index, { id: matchId, routeId }] of matches.entries()) {\n              const existingMatch = this.getMatch(matchId)!\n              const parentMatchId = matches[index - 1]?.id\n\n              if (\n                // If we are in the middle of a load, either of these will be present\n                // (not to be confused with `loadPromise`, which is always defined)\n                existingMatch.beforeLoadPromise ||\n                existingMatch.loaderPromise\n              ) {\n                // Wait for the beforeLoad to resolve before we continue\n                await existingMatch.beforeLoadPromise\n              } else {\n                // If we are not in the middle of a load, start it\n                try {\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    loadPromise: createControlledPromise<void>(() => {\n                      prev.loadPromise?.resolve()\n                    }),\n                    beforeLoadPromise: createControlledPromise<void>(),\n                  }))\n\n                  const route = this.looseRoutesById[routeId]!\n                  const abortController = new AbortController()\n\n                  const pendingMs =\n                    route.options.pendingMs ?? this.options.defaultPendingMs\n\n                  const shouldPending = !!(\n                    onReady &&\n                    !this.isServer &&\n                    !preload &&\n                    (route.options.loader || route.options.beforeLoad) &&\n                    typeof pendingMs === 'number' &&\n                    pendingMs !== Infinity &&\n                    (route.options.pendingComponent ??\n                      this.options.defaultPendingComponent)\n                  )\n\n                  let pendingTimeout: ReturnType<typeof setTimeout>\n\n                  if (shouldPending) {\n                    // If we might show a pending component, we need to wait for the\n                    // pending promise to resolve before we start showing that state\n                    pendingTimeout = setTimeout(() => {\n                      try {\n                        // Update the match and prematurely resolve the loadMatches promise so that\n                        // the pending component can start rendering\n                        triggerOnReady()\n                      } catch {}\n                    }, pendingMs)\n                  }\n\n                  const { paramsError, searchError } = this.getMatch(matchId)!\n\n                  if (paramsError) {\n                    handleSerialError(index, paramsError, 'PARSE_PARAMS')\n                  }\n\n                  if (searchError) {\n                    handleSerialError(index, searchError, 'VALIDATE_SEARCH')\n                  }\n\n                  const getParentMatchContext = () =>\n                    parentMatchId\n                      ? this.getMatch(parentMatchId)!.context\n                      : (this.options.context ?? {})\n\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    isFetching: 'beforeLoad',\n                    fetchCount: prev.fetchCount + 1,\n                    abortController,\n                    pendingTimeout,\n                    context: {\n                      ...getParentMatchContext(),\n                      ...prev.__routeContext,\n                      ...prev.__beforeLoadContext,\n                    },\n                  }))\n\n                  const { search, params, context, cause } =\n                    this.getMatch(matchId)!\n\n                  const beforeLoadFnContext: BeforeLoadContextOptions<\n                    any,\n                    any,\n                    any,\n                    any,\n                    any\n                  > = {\n                    search,\n                    abortController,\n                    params,\n                    preload: !!preload,\n                    context,\n                    location,\n                    navigate: (opts: any) =>\n                      this.navigate({ ...opts, _fromLocation: location }),\n                    buildLocation: this.buildLocation,\n                    cause: preload ? 'preload' : cause,\n                  }\n\n                  let beforeLoadContext =\n                    (await route.options.beforeLoad?.(beforeLoadFnContext)) ??\n                    {}\n\n                  if (this.serializeLoaderData) {\n                    beforeLoadContext = this.serializeLoaderData(\n                      '__beforeLoadContext',\n                      beforeLoadContext,\n                      {\n                        router: this,\n                        match: this.getMatch(matchId)!,\n                      },\n                    )\n                  }\n\n                  if (\n                    isRedirect(beforeLoadContext) ||\n                    isNotFound(beforeLoadContext)\n                  ) {\n                    handleSerialError(index, beforeLoadContext, 'BEFORE_LOAD')\n                  }\n\n                  updateMatch(matchId, (prev) => {\n                    return {\n                      ...prev,\n                      __beforeLoadContext: beforeLoadContext,\n                      context: {\n                        ...getParentMatchContext(),\n                        ...prev.__routeContext,\n                        ...beforeLoadContext,\n                      },\n                      abortController,\n                    }\n                  })\n                } catch (err) {\n                  handleSerialError(index, err, 'BEFORE_LOAD')\n                }\n\n                updateMatch(matchId, (prev) => {\n                  prev.beforeLoadPromise?.resolve()\n\n                  return {\n                    ...prev,\n                    beforeLoadPromise: undefined,\n                    isFetching: false,\n                  }\n                })\n              }\n            }\n\n            const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n            const matchPromises: Array<Promise<any>> = []\n\n            validResolvedMatches.forEach(({ id: matchId, routeId }, index) => {\n              matchPromises.push(\n                (async () => {\n                  const { loaderPromise: prevLoaderPromise } =\n                    this.getMatch(matchId)!\n\n                  if (prevLoaderPromise) {\n                    await prevLoaderPromise\n                  } else {\n                    const parentMatchPromise = matchPromises[index - 1]\n                    const route = this.looseRoutesById[routeId]!\n\n                    const getLoaderContext = (): LoaderFnContext => {\n                      const {\n                        params,\n                        loaderDeps,\n                        abortController,\n                        context,\n                        cause,\n                      } = this.getMatch(matchId)!\n\n                      return {\n                        params,\n                        deps: loaderDeps,\n                        preload: !!preload,\n                        parentMatchPromise,\n                        abortController: abortController,\n                        context,\n                        location,\n                        navigate: (opts) =>\n                          this.navigate({ ...opts, _fromLocation: location }),\n                        cause: preload ? 'preload' : cause,\n                        route,\n                      }\n                    }\n\n                    // This is where all of the stale-while-revalidate magic happens\n                    const age = Date.now() - this.getMatch(matchId)!.updatedAt\n\n                    const staleAge = preload\n                      ? (route.options.preloadStaleTime ??\n                        this.options.defaultPreloadStaleTime ??\n                        30_000) // 30 seconds for preloads by default\n                      : (route.options.staleTime ??\n                        this.options.defaultStaleTime ??\n                        0)\n\n                    const shouldReloadOption = route.options.shouldReload\n\n                    // Default to reloading the route all the time\n                    // Allow shouldReload to get the last say,\n                    // if provided.\n                    const shouldReload =\n                      typeof shouldReloadOption === 'function'\n                        ? shouldReloadOption(getLoaderContext())\n                        : shouldReloadOption\n\n                    updateMatch(matchId, (prev) => ({\n                      ...prev,\n                      loaderPromise: createControlledPromise<void>(),\n                      preload:\n                        !!preload &&\n                        !this.state.matches.find((d) => d.id === matchId),\n                    }))\n\n                    const runLoader = async () => {\n                      try {\n                        // If the Matches component rendered\n                        // the pending component and needs to show it for\n                        // a minimum duration, we''ll wait for it to resolve\n                        // before committing to the match and resolving\n                        // the loadPromise\n                        const potentialPendingMinPromise = async () => {\n                          const latestMatch = this.getMatch(matchId)!\n\n                          if (latestMatch.minPendingPromise) {\n                            await latestMatch.minPendingPromise\n                          }\n                        }\n\n                        // Actually run the loader and handle the result\n                        try {\n                          route._lazyPromise =\n                            route._lazyPromise ||\n                            (route.lazyFn\n                              ? route.lazyFn().then((lazyRoute) => {\n                                  Object.assign(\n                                    route.options,\n                                    lazyRoute.options,\n                                  )\n                                })\n                              : Promise.resolve())\n\n                          // If for some reason lazy resolves more lazy components...\n                          // We'll wait for that before pre attempt to preload any\n                          // components themselves.\n                          const componentsPromise =\n                            this.getMatch(matchId)!.componentsPromise ||\n                            route._lazyPromise.then(() =>\n                              Promise.all(\n                                componentTypes.map(async (type) => {\n                                  const component = route.options[type]\n\n                                  if ((component as any)?.preload) {\n                                    await (component as any).preload()\n                                  }\n                                }),\n                              ),\n                            )\n\n                          // Otherwise, load the route\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            isFetching: 'loader',\n                            componentsPromise,\n                          }))\n\n                          // Lazy option can modify the route options,\n                          // so we need to wait for it to resolve before\n                          // we can use the options\n                          await route._lazyPromise\n\n                          // Kick off the loader!\n                          let loaderData =\n                            await route.options.loader?.(getLoaderContext())\n\n                          if (this.serializeLoaderData) {\n                            loaderData = this.serializeLoaderData(\n                              'loaderData',\n                              loaderData,\n                              {\n                                router: this,\n                                match: this.getMatch(matchId)!,\n                              },\n                            )\n                          }\n\n                          handleRedirectAndNotFound(\n                            this.getMatch(matchId)!,\n                            loaderData,\n                          )\n\n                          await potentialPendingMinPromise()\n\n                          const meta = route.options.meta?.({\n                            matches,\n                            match: this.getMatch(matchId)!,\n                            params: this.getMatch(matchId)!.params,\n                            loaderData,\n                          })\n\n                          const headers = route.options.headers?.({\n                            loaderData,\n                          })\n\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            error: undefined,\n                            status: 'success',\n                            isFetching: false,\n                            updatedAt: Date.now(),\n                            loaderData,\n                            meta,\n                            headers,\n                          }))\n                        } catch (e) {\n                          let error = e\n\n                          await potentialPendingMinPromise()\n\n                          handleRedirectAndNotFound(this.getMatch(matchId)!, e)\n\n                          try {\n                            route.options.onError?.(e)\n                          } catch (onErrorError) {\n                            error = onErrorError\n                            handleRedirectAndNotFound(\n                              this.getMatch(matchId)!,\n                              onErrorError,\n                            )\n                          }\n\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            error,\n                            status: 'error',\n                            isFetching: false,\n                          }))\n                        }\n\n                        // Last but not least, wait for the the component\n                        // to be preloaded before we resolve the match\n                        await this.getMatch(matchId)!.componentsPromise\n                      } catch (err) {\n                        handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n                      }\n                    }\n\n                    // If the route is successful and still fresh, just resolve\n                    const { status, invalid } = this.getMatch(matchId)!\n\n                    if (preload && route.options.preload === false) {\n                      // Do nothing\n                    } else if (\n                      status === 'success' &&\n                      (invalid || (shouldReload ?? age > staleAge))\n                    ) {\n                      ;(async () => {\n                        try {\n                          await runLoader()\n                        } catch (err) {}\n                      })()\n                    } else if (status !== 'success') {\n                      await runLoader()\n                    }\n\n                    const { loaderPromise, loadPromise } =\n                      this.getMatch(matchId)!\n\n                    loaderPromise?.resolve()\n                    loadPromise?.resolve()\n                  }\n\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    isFetching: false,\n                    loaderPromise: undefined,\n                  }))\n                })(),\n              )\n            })\n\n            await Promise.all(matchPromises)\n\n            resolveAll()\n          } catch (err) {\n            rejectAll(err)\n          }\n        })()\n      })\n      await triggerOnReady()\n    } catch (err) {\n      if (isRedirect(err) || isNotFound(err)) {\n        if (isNotFound(err) && !preload) {\n          await triggerOnReady()\n        }\n        throw err\n      }\n    }\n\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => ({\n      ...d,\n      invalid: true,\n      ...(d.status === 'error'\n        ? ({ status: 'pending', error: undefined } as const)\n        : {}),\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    return this.load()\n  }\n\n  resolveRedirect = (err: AnyRedirect): ResolvedRedirect => {\n    const redirect = err as ResolvedRedirect\n\n    if (!redirect.href) {\n      redirect.href = this.buildLocation(redirect as any).href\n    }\n\n    return redirect\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? (route.options.preloadGcTime ??\n                this.options.defaultPreloadGcTime)\n              : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async <\n    TFrom extends RoutePaths<TRouteTree> | string = string,\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n    TMaskTo extends string = '',\n  >(\n    opts: NavigateOptions<\n      Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>,\n      TFrom,\n      TTo,\n      TMaskFrom,\n      TMaskTo\n    >,\n  ): Promise<Array<AnyRouteMatch> | undefined> => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next, {\n      throwOnError: true,\n      preload: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ].map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    try {\n      matches = await this.loadMatches({\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        return await this.preloadRoute({\n          ...(err as any),\n          _fromLocation: next,\n        })\n      }\n      // Preload errors are not fatal, but we should still log them\n      console.error(err)\n      return undefined\n    }\n  }\n\n  matchRoute = <\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<\n      Router<TRouteTree, TTrailingSlashOption, TDehydrated, TSerializedError>,\n      TFrom,\n      TTo\n    >,\n    opts?: MatchRouteOptions,\n  ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, true)) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    const pickError =\n      this.options.errorSerializer?.serialize ?? defaultSerializeError\n\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) => {\n          return {\n            ...pick(d, ['id', 'status', 'updatedAt']),\n            // If an error occurs server-side during SSRing,\n            // send a small subset of the error to the client\n            error: d.error\n              ? {\n                  data: pickError(d.error),\n                  __isServerError: true,\n                }\n              : undefined,\n            // NOTE: We don't send the loader data here, because\n            // there is a potential that it needs to be streamed.\n            // Instead, we render it next to the route match in the HTML\n            // which gives us the potential to stream it via suspense.\n          }\n        }),\n      },\n      manifest: this.manifest,\n    }\n  }\n\n  hydrate = () => {\n    // Client hydrates from window\n    let ctx: HydrationCtx | undefined\n\n    if (typeof document !== 'undefined') {\n      ctx = this.options.transformer.parse(window.__TSR__?.dehydrated) as any\n    }\n\n    invariant(\n      ctx,\n      'Expected to find a dehydrated data on window.__TSR__.dehydrated... but we did not. Please file an issue!',\n    )\n\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    const matches = this.matchRoutes(this.state.location).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      return {\n        ...match,\n        ...dehydratedMatch,\n      }\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n\n    this.manifest = ctx.router.manifest\n  }\n\n  injectedHtml: Array<() => string> = []\n  injectHtml: (html: string) => void = (html) => {\n    const cb = () => {\n      this.injectedHtml = this.injectedHtml.filter((d) => d !== cb)\n      return html\n    }\n\n    this.injectedHtml.push(cb)\n  }\n  streamedKeys: Set<string> = new Set()\n\n  getStreamedValue = <T>(key: string): T | undefined => {\n    if (this.isServer) {\n      return undefined\n    }\n\n    const streamedValue = window.__TSR__?.streamedValues[key]\n\n    if (!streamedValue) {\n      return\n    }\n\n    if (!streamedValue.parsed) {\n      streamedValue.parsed = this.options.transformer.parse(streamedValue.value)\n    }\n\n    return streamedValue.parsed\n  }\n\n  streamValue = (key: string, value: any) => {\n    warning(\n      !this.streamedKeys.has(key),\n      'Key has already been streamed: ' + key,\n    )\n\n    this.streamedKeys.add(key)\n    const children = `__TSR__.streamedValues['${key}'] = { value: ${this.serializer?.(this.options.transformer.stringify(value))}}`\n\n    this.injectHtml(\n      `<script class='tsr-once'>${children}${\n        process.env.NODE_ENV === 'development'\n          ? `; console.info(\\`Injected From Server:\n        ${children}\\`)`\n          : ''\n      }; __TSR__.cleanScripts()</script>`,\n    )\n  }\n\n  _handleNotFound = (\n    matches: Array<AnyRouteMatch>,\n    err: NotFoundError,\n    {\n      updateMatch = this.updateMatch,\n    }: {\n      updateMatch?: (\n        id: string,\n        updater: (match: AnyRouteMatch) => AnyRouteMatch,\n      ) => void\n    } = {},\n  ) => {\n    const matchesByRouteId = Object.fromEntries(\n      matches.map((match) => [match.routeId, match]),\n    ) as Record<string, AnyRouteMatch>\n\n    // Start at the route that errored or default to the root route\n    let routeCursor =\n      (err.global\n        ? this.looseRoutesById[rootRouteId]\n        : this.looseRoutesById[err.routeId]) ||\n      this.looseRoutesById[rootRouteId]!\n\n    // Go up the tree until we find a route with a notFoundComponent or we hit the root\n    while (\n      !routeCursor.options.notFoundComponent &&\n      !this.options.defaultNotFoundComponent &&\n      routeCursor.id !== rootRouteId\n    ) {\n      routeCursor = routeCursor.parentRoute\n\n      invariant(\n        routeCursor,\n        'Found invalid route tree while trying to find not-found handler.',\n      )\n    }\n\n    const match = matchesByRouteId[routeCursor.id]\n\n    invariant(match, 'Could not find match for route: ' + routeCursor.id)\n\n    // Assign the error to the match\n\n    updateMatch(match.id, (prev) => ({\n      ...prev,\n      status: 'notFound',\n      error: err,\n      isFetching: false,\n    }))\n\n    if ((err as any).routerCode === 'BEFORE_LOAD' && routeCursor.parentRoute) {\n      err.routeId = routeCursor.parentRoute.id\n      this._handleNotFound(matches, err, {\n        updateMatch,\n      })\n    }\n  }\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}