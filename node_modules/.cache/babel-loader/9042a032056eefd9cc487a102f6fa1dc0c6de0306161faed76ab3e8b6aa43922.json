{"ast":null,"code":"import { jsx, jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport warning from \"tiny-warning\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { Transitioner } from \"./Transitioner.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { Match } from \"./Match.js\";\nimport { SafeFragment } from \"./SafeFragment.js\";\nconst isMatch = (match, path) => {\n  const parts = path.split(\".\");\n  let part;\n  let value = match;\n  while ((part = parts.shift()) != null && value != null) {\n    value = value[part];\n  }\n  return value != null;\n};\nfunction Matches() {\n  const router = useRouter();\n  const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */jsx(router.options.defaultPendingComponent, {}) : null;\n  const ResolvedSuspense = router.isServer || typeof document !== \"undefined\" && window.__TSR__ ? SafeFragment : React.Suspense;\n  const inner = /* @__PURE__ */jsxs(ResolvedSuspense, {\n    fallback: pendingElement,\n    children: [/* @__PURE__ */jsx(Transitioner, {}), /* @__PURE__ */jsx(MatchesInner, {})]\n  });\n  return router.options.InnerWrap ? /* @__PURE__ */jsx(router.options.InnerWrap, {\n    children: inner\n  }) : inner;\n}\nfunction MatchesInner() {\n  const matchId = useRouterState({\n    select: s => {\n      var _a;\n      return (_a = s.matches[0]) == null ? void 0 : _a.id;\n    }\n  });\n  const resetKey = useRouterState({\n    select: s => s.loadedAt\n  });\n  return /* @__PURE__ */jsx(matchContext.Provider, {\n    value: matchId,\n    children: /* @__PURE__ */jsx(CatchBoundary, {\n      getResetKey: () => resetKey,\n      errorComponent: ErrorComponent,\n      onCatch: error => {\n        warning(false, `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`);\n        warning(false, error.message || error.toString());\n      },\n      children: matchId ? /* @__PURE__ */jsx(Match, {\n        matchId\n      }) : null\n    })\n  });\n}\nfunction useMatchRoute() {\n  const router = useRouter();\n  useRouterState({\n    select: s => [s.location.href, s.resolvedLocation.href, s.status]\n  });\n  return React.useCallback(opts => {\n    const {\n      pending,\n      caseSensitive,\n      fuzzy,\n      includeSearch,\n      ...rest\n    } = opts;\n    return router.matchRoute(rest, {\n      pending,\n      caseSensitive,\n      fuzzy,\n      includeSearch\n    });\n  }, [router]);\n}\nfunction MatchRoute(props) {\n  const matchRoute = useMatchRoute();\n  const params = matchRoute(props);\n  if (typeof props.children === \"function\") {\n    return props.children(params);\n  }\n  return params ? props.children : null;\n}\nfunction useMatches(opts) {\n  return useRouterState({\n    select: state => {\n      const matches = state.matches;\n      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;\n    }\n  });\n}\nfunction useParentMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: matches => {\n      matches = matches.slice(0, matches.findIndex(d => d.id === contextMatchId));\n      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;\n    }\n  });\n}\nfunction useChildMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: matches => {\n      matches = matches.slice(matches.findIndex(d => d.id === contextMatchId) + 1);\n      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;\n    }\n  });\n}\nexport { MatchRoute, Matches, isMatch, useChildMatches, useMatchRoute, useMatches, useParentMatches };","map":{"version":3,"names":["isMatch","match","path","parts","split","part","value","shift","Matches","router","useRouter","pendingElement","options","defaultPendingComponent","jsx","ResolvedSuspense","isServer","document","window","__TSR__","SafeFragment","React","Suspense","inner","jsxs","fallback","children","Transitioner","MatchesInner","InnerWrap","matchId","useRouterState","select","s","_a","matches","id","resetKey","loadedAt","matchContext","Provider","CatchBoundary","getResetKey","errorComponent","ErrorComponent","onCatch","error","warning","message","toString","Match","useMatchRoute","location","href","resolvedLocation","status","useCallback","opts","pending","caseSensitive","fuzzy","includeSearch","rest","matchRoute","MatchRoute","props","params","useMatches","state","useParentMatches","contextMatchId","useContext","slice","findIndex","d","useChildMatches"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react-test/carroway-react-test/node_modules/@tanstack/react-router/src/Matches.tsx"],"sourcesContent":["import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { Transitioner } from './Transitioner'\nimport {\n  type AnyRoute,\n  type ReactNode,\n  type StaticDataRouteOption,\n} from './route'\nimport { matchContext } from './matchContext'\nimport { Match } from './Match'\nimport { SafeFragment } from './SafeFragment'\nimport type { AnyRouter, RegisteredRouter } from './router'\nimport type { ResolveRelativePath, ToOptions } from './link'\nimport type {\n  AllContext,\n  AllLoaderData,\n  AllParams,\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport type {\n  Constrain,\n  ControlledPromise,\n  DeepPartial,\n  NoInfer,\n} from './utils'\n\nexport type AnyMatchAndValue = { match: any; value: any }\n\nexport type FindValueByIndex<\n  TKey,\n  TValue extends ReadonlyArray<any>,\n> = TKey extends `${infer TIndex extends number}` ? TValue[TIndex] : never\n\nexport type FindValueByKey<TKey, TValue> =\n  TValue extends ReadonlyArray<any>\n    ? FindValueByIndex<TKey, TValue>\n    : TValue[TKey & keyof TValue]\n\nexport type CreateMatchAndValue<TMatch, TValue> = TValue extends any\n  ? {\n      match: TMatch\n      value: TValue\n    }\n  : never\n\nexport type NextMatchAndValue<\n  TKey,\n  TMatchAndValue extends AnyMatchAndValue,\n> = TMatchAndValue extends any\n  ? CreateMatchAndValue<\n      TMatchAndValue['match'],\n      FindValueByKey<TKey, TMatchAndValue['value']>\n    >\n  : never\n\nexport type IsMatchKeyOf<TValue> =\n  TValue extends ReadonlyArray<any>\n    ? number extends TValue['length']\n      ? `${number}`\n      : keyof TValue & `${number}`\n    : TValue extends object\n      ? keyof TValue & string\n      : never\n\nexport type IsMatchPath<\n  TParentPath extends string,\n  TMatchAndValue extends AnyMatchAndValue,\n> = `${TParentPath}${IsMatchKeyOf<TMatchAndValue['value']>}`\n\nexport type IsMatchResult<\n  TKey,\n  TMatchAndValue extends AnyMatchAndValue,\n> = TMatchAndValue extends any\n  ? TKey extends keyof TMatchAndValue['value']\n    ? TMatchAndValue['match']\n    : never\n  : never\n\nexport type IsMatchParse<\n  TPath,\n  TMatchAndValue extends AnyMatchAndValue,\n  TParentPath extends string = '',\n> = TPath extends `${string}.${string}`\n  ? TPath extends `${infer TFirst}.${infer TRest}`\n    ? IsMatchParse<\n        TRest,\n        NextMatchAndValue<TFirst, TMatchAndValue>,\n        `${TParentPath}${TFirst}.`\n      >\n    : never\n  : {\n      path: IsMatchPath<TParentPath, TMatchAndValue>\n      result: IsMatchResult<TPath, TMatchAndValue>\n    }\n\nexport type IsMatch<TMatch, TPath> = IsMatchParse<\n  TPath,\n  TMatch extends any ? { match: TMatch; value: TMatch } : never\n>\n\n/**\n * Narrows matches based on a path\n * @experimental\n */\nexport const isMatch = <TMatch, TPath extends string>(\n  match: TMatch,\n  path: Constrain<TPath, IsMatch<TMatch, TPath>['path']>,\n): match is IsMatch<TMatch, TPath>['result'] => {\n  const parts = (path as string).split('.')\n  let part\n  let value: any = match\n\n  while ((part = parts.shift()) != null && value != null) {\n    value = value[part]\n  }\n\n  return value != null\n}\n\nexport interface RouteMatch<\n  TRouteId,\n  TFullPath,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TLoaderDeps,\n> {\n  id: string\n  routeId: TRouteId\n  fullPath: TFullPath\n  index: number\n  pathname: string\n  params: TAllParams\n  status: 'pending' | 'success' | 'error' | 'redirected' | 'notFound'\n  isFetching: false | 'beforeLoad' | 'loader'\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  componentsPromise?: Promise<Array<void>>\n  loadPromise?: ControlledPromise<void>\n  beforeLoadPromise?: ControlledPromise<void>\n  loaderPromise?: ControlledPromise<void>\n  loaderData?: TLoaderData\n  __routeContext: Record<string, unknown>\n  __beforeLoadContext: Record<string, unknown>\n  context: TAllContext\n  search: TFullSearchSchema\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: TLoaderDeps\n  preload: boolean\n  invalid: boolean\n  meta?: Array<React.JSX.IntrinsicElements['meta']>\n  links?: Array<React.JSX.IntrinsicElements['link']>\n  scripts?: Array<React.JSX.IntrinsicElements['script']>\n  headers?: Record<string, string>\n  globalNotFound?: boolean\n  staticData: StaticDataRouteOption\n  minPendingPromise?: ControlledPromise<void>\n  pendingTimeout?: ReturnType<typeof setTimeout>\n}\n\nexport type MakeRouteMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId = ParseRoute<TRouteTree>['id'],\n  TStrict extends boolean = true,\n  TTypes extends AnyRoute['types'] = RouteById<TRouteTree, TRouteId>['types'],\n  TFullPath = TTypes['fullPath'],\n  TAllParams = TStrict extends false\n    ? AllParams<TRouteTree>\n    : TTypes['allParams'],\n  TFullSearchSchema = TStrict extends false\n    ? FullSearchSchema<TRouteTree>\n    : TTypes['fullSearchSchema'],\n  TLoaderData = TStrict extends false\n    ? AllLoaderData<TRouteTree>\n    : TTypes['loaderData'],\n  TAllContext = TStrict extends false\n    ? AllContext<TRouteTree>\n    : TTypes['allContext'],\n  TLoaderDeps = TTypes['loaderDeps'],\n> = RouteMatch<\n  TRouteId,\n  TFullPath,\n  TAllParams,\n  TFullSearchSchema,\n  TLoaderData,\n  TAllContext,\n  TLoaderDeps\n>\n\nexport type AnyRouteMatch = RouteMatch<any, any, any, any, any, any, any>\n\nexport function Matches() {\n  const router = useRouter()\n\n  const pendingElement = router.options.defaultPendingComponent ? (\n    <router.options.defaultPendingComponent />\n  ) : null\n\n  // Do not render a root Suspense during SSR or hydrating from SSR\n  const ResolvedSuspense =\n    router.isServer || (typeof document !== 'undefined' && window.__TSR__)\n      ? SafeFragment\n      : React.Suspense\n\n  const inner = (\n    <ResolvedSuspense fallback={pendingElement}>\n      <Transitioner />\n      <MatchesInner />\n    </ResolvedSuspense>\n  )\n\n  return router.options.InnerWrap ? (\n    <router.options.InnerWrap>{inner}</router.options.InnerWrap>\n  ) : (\n    inner\n  )\n}\n\nfunction MatchesInner() {\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id\n    },\n  })\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => resetKey}\n        errorComponent={ErrorComponent}\n        onCatch={(error) => {\n          warning(\n            false,\n            `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n          )\n          warning(false, error.message || error.toString())\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n  TOptions extends ToOptions<\n    TRouter,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  > = ToOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n  TRelaxedOptions = Omit<TOptions, 'search' | 'params'> &\n    DeepPartial<Pick<TOptions, 'search' | 'params'>>,\n> = TRelaxedOptions & MatchRouteOptions\n\nexport function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>() {\n  const router = useRouter()\n\n  useRouterState({\n    select: (s) => [s.location.href, s.resolvedLocation.href, s.status],\n  })\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouter['routeTree']> | string = string,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouter['routeTree']> | string = TFrom,\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ):\n      | false\n      | RouteByPath<TRouter['routeTree'], TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    },\n    [router],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouter['routeTree'],\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => ReactNode)\n    | React.ReactNode\n}\n\nexport function MatchRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends RoutePaths<TRouter['routeTree']> = RoutePaths<\n    TRouter['routeTree']\n  >,\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouter['routeTree']> = TFrom,\n  TMaskTo extends string = '',\n>(props: MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return params ? props.children : null\n}\n\nexport type MakeRouteMatches<\n  TRouter extends AnyRouter = AnyRouter,\n  TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>,\n> = TRoute extends any\n  ? RouteMatch<\n      TRoute['id'],\n      TRoute['fullPath'],\n      TRoute['types']['allParams'],\n      TRoute['types']['fullSearchSchema'],\n      TRoute['types']['loaderData'],\n      TRoute['types']['allContext'],\n      TRoute['types']['loaderDeps']\n    >\n  : never\n\nexport function useMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TRouteMatch = MakeRouteMatches<TRouter>,\n  T = Array<TRouteMatch>,\n>(opts?: { select?: (matches: Array<TRouteMatch>) => T }): T {\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId>,\n  T = Array<TRouteMatch>,\n>(opts?: { select?: (matches: Array<TRouteMatch>) => T }): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId),\n      )\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n\nexport function useChildMatches<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n  TRouteMatch = MakeRouteMatch<TRouteTree, TRouteId>,\n  T = Array<TRouteMatch>,\n>(opts?: { select?: (matches: Array<TRouteMatch>) => T }): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1,\n      )\n      return opts?.select\n        ? opts.select(matches as Array<TRouteMatch>)\n        : (matches as T)\n    },\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}