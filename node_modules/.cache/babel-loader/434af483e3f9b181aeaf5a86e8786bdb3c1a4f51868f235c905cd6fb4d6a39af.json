{"ast":null,"code":"import { decode, encode } from \"./qss.js\";\nconst defaultParseSearch = parseSearchWith(JSON.parse);\nconst defaultStringifySearch = stringifySearchWith(JSON.stringify, JSON.parse);\nfunction parseSearchWith(parser) {\n  return searchStr => {\n    if (searchStr.substring(0, 1) === \"?\") {\n      searchStr = searchStr.substring(1);\n    }\n    const query = decode(searchStr);\n    for (const key in query) {\n      const value = query[key];\n      if (typeof value === \"string\") {\n        try {\n          query[key] = parser(value);\n        } catch (err) {}\n      }\n    }\n    return query;\n  };\n}\nfunction stringifySearchWith(stringify, parser) {\n  function stringifyValue(val) {\n    if (typeof val === \"object\" && val !== null) {\n      try {\n        return stringify(val);\n      } catch (err) {}\n    } else if (typeof val === \"string\" && typeof parser === \"function\") {\n      try {\n        parser(val);\n        return stringify(val);\n      } catch (err) {}\n    }\n    return val;\n  }\n  return search => {\n    search = {\n      ...search\n    };\n    Object.keys(search).forEach(key => {\n      const val = search[key];\n      if (typeof val === \"undefined\" || val === void 0) {\n        delete search[key];\n      } else {\n        search[key] = stringifyValue(val);\n      }\n    });\n    const searchStr = encode(search).toString();\n    return searchStr ? `?${searchStr}` : \"\";\n  };\n}\nexport { defaultParseSearch, defaultStringifySearch, parseSearchWith, stringifySearchWith };","map":{"version":3,"names":["defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","substring","query","decode","key","value","err","stringifyValue","val","search","Object","keys","forEach","encode","toString"],"sources":["/Users/carzard707/Documents/GitHub/carroway-react/node_modules/@tanstack/react-router/src/searchParams.ts"],"sourcesContent":["import { decode, encode } from './qss'\nimport type { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    const query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (const key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    Object.keys(search).forEach((key) => {\n      const val = search[key]\n      if (typeof val === 'undefined' || val === undefined) {\n        delete search[key]\n      } else {\n        search[key] = stringifyValue(val)\n      }\n    })\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n"],"mappings":";AAGa,MAAAA,kBAAA,GAAqBC,eAAA,CAAgBC,IAAA,CAAKC,KAAK;AACrD,MAAMC,sBAAA,GAAyBC,mBAAA,CACpCH,IAAA,CAAKI,SAAA,EACLJ,IAAA,CAAKC,KACP;AAEO,SAASF,gBAAgBM,MAAA,EAA8B;EAC5D,OAAQC,SAAA,IAAuC;IAC7C,IAAIA,SAAA,CAAUC,SAAA,CAAU,GAAG,CAAC,MAAM,KAAK;MACzBD,SAAA,GAAAA,SAAA,CAAUC,SAAA,CAAU,CAAC;IACnC;IAEM,MAAAC,KAAA,GAAiCC,MAAA,CAAOH,SAAS;IAGvD,WAAWI,GAAA,IAAOF,KAAA,EAAO;MACjB,MAAAG,KAAA,GAAQH,KAAA,CAAME,GAAG;MACnB,WAAOC,KAAA,KAAU,UAAU;QACzB;UACIH,KAAA,CAAAE,GAAG,IAAIL,MAAA,CAAOM,KAAK;QAAA,SAClBC,GAAA,EAAK,CAEd;MACF;IACF;IAEO,OAAAJ,KAAA;EAAA;AAEX;AAEgB,SAAAL,oBACdC,SAAA,EACAC,MAAA,EACA;EACA,SAASQ,eAAeC,GAAA,EAAU;IAChC,IAAI,OAAOA,GAAA,KAAQ,YAAYA,GAAA,KAAQ,MAAM;MACvC;QACF,OAAOV,SAAA,CAAUU,GAAG;MAAA,SACbF,GAAA,EAAK,CAEd;IAAA,WACS,OAAOE,GAAA,KAAQ,YAAY,OAAOT,MAAA,KAAW,YAAY;MAC9D;QAGFA,MAAA,CAAOS,GAAG;QACV,OAAOV,SAAA,CAAUU,GAAG;MAAA,SACbF,GAAA,EAAK,CAEd;IACF;IACO,OAAAE,GAAA;EACT;EAEA,OAAQC,MAAA,IAAgC;IAC7BA,MAAA;MAAE,GAAGA;IAAA;IAEdC,MAAA,CAAOC,IAAA,CAAKF,MAAM,EAAEG,OAAA,CAASR,GAAA,IAAQ;MAC7B,MAAAI,GAAA,GAAMC,MAAA,CAAOL,GAAG;MACtB,IAAI,OAAOI,GAAA,KAAQ,eAAeA,GAAA,KAAQ,QAAW;QACnD,OAAOC,MAAA,CAAOL,GAAG;MAAA,OACZ;QACEK,MAAA,CAAAL,GAAG,IAAIG,cAAA,CAAeC,GAAG;MAClC;IAAA,CACD;IAED,MAAMR,SAAA,GAAYa,MAAA,CAAOJ,MAAgC,EAAEK,QAAA,CAAS;IAE7D,OAAAd,SAAA,GAAY,IAAIA,SAAS,KAAK;EAAA;AAEzC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}